<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Betterlin ’s Blog</title>
  
  <subtitle>浪住, 别稳, 能输!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-07-20T03:38:42.296Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>betterlin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ReactDOM.render 初始化过程浅析</title>
    <link href="http://yoursite.com/2021/07/19/ReactDOM-render%E5%AE%9E%E7%8E%B0%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2021/07/19/ReactDOM-render实现浅析/</id>
    <published>2021-07-19T15:16:24.000Z</published>
    <updated>2021-07-20T03:38:42.296Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/react.jpg" alt="banner"></p><h2 id="ReactDOM-render-用法"><a href="#ReactDOM-render-用法" class="headerlink" title="ReactDOM.render 用法"></a>ReactDOM.render 用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(&lt;Root /&gt;, document.getElementById(&apos;root&apos;))</span><br></pre></td></tr></table></figure><h2 id="ReactDOM-定义"><a href="#ReactDOM-定义" class="headerlink" title="ReactDOM 定义"></a>ReactDOM 定义</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactDOM: <span class="built_in">Object</span> = &#123;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  hydrate(element: React$Node, <span class="attr">container</span>: DOMContainer, <span class="attr">callback</span>: ?<span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> legacyRenderSubtreeIntoContainer(</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      element,</span><br><span class="line">      container,</span><br><span class="line">      <span class="literal">true</span>,</span><br><span class="line">      callback,</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">  render(</span><br><span class="line">    element: React$Element&lt;any&gt;,</span><br><span class="line">    container: DOMContainer,</span><br><span class="line">    callback: ?<span class="built_in">Function</span>,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> legacyRenderSubtreeIntoContainer(</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      element,</span><br><span class="line">      container,</span><br><span class="line">      <span class="literal">false</span>,</span><br><span class="line">      callback,</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hydrate 和 render 本质都是调用 legacyRenderSubtreeIntoContainer 方法，只是第四个参数 forceHydrate 传入有区别，render 我们很清楚知道就是进行渲染调用，那 hydrate 是用来做什么？</p><blockquote><p>hydrate 描述的是 ReactDOM 复用 ReactDOMServer 服务端渲染的内容时尽可能保留结构，并补充事件绑定等 Client 特有内容的过程。</p></blockquote><h2 id="ReactDOM-render-过程"><a href="#ReactDOM-render-过程" class="headerlink" title="ReactDOM render 过程"></a>ReactDOM render 过程</h2><ol><li>render 调用 legacyRenderSubtreeIntoContainer</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">legacyRenderSubtreeIntoContainer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentComponent: ?React$Component&lt;any, any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  children: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  container: DOMContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">  forceHydrate: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  <span class="keyword">let</span> root: Root = (container._reactRootContainer: any);</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="comment">// 创建 ReactRoot</span></span><br><span class="line">    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(</span><br><span class="line">      container,</span><br><span class="line">      forceHydrate,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> originalCallback = callback;</span><br><span class="line">      <span class="comment">// 封装回调函数</span></span><br><span class="line">      callback = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> instance = DOMRenderer.getPublicRootInstance(root._internalRoot);</span><br><span class="line">        originalCallback.call(instance);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行渲染</span></span><br><span class="line">    DOMRenderer.unbatchedUpdates(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (parentComponent != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 忽略</span></span><br><span class="line">        root.legacy_renderSubtreeIntoContainer(</span><br><span class="line">          parentComponent,</span><br><span class="line">          children,</span><br><span class="line">          callback,</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 ReactRoot 的 render 方法</span></span><br><span class="line">        root.render(children, callback);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> DOMRenderer.getPublicRootInstance(root._internalRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>legacyRenderSubtreeIntoContainer 通过 legacyCreateRootFromDOMContainer 这个方法创建了一个 ReactRoot 实例，然后赋值给 root 和 container._reactRootContainer，完成后执行回调函数的封装，接着执行<br>unbatchedUpdates 的回调函数，会执行 root 的 render 方法，也就是 ReactRoot 的原型方法 render，最后传入 root._internalRoot，执行后返回 DOMRenderer.getPublicRootInstance 的结果;</p><ol start="2"><li>legacyCreateRootFromDOMContainer 实现过程</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">legacyCreateRootFromDOMContainer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  container: DOMContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">  forceHydrate: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Root</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> shouldHydrate =</span><br><span class="line">    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);</span><br><span class="line">  <span class="keyword">if</span> (!shouldHydrate) &#123;</span><br><span class="line">    <span class="keyword">let</span> warned = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> rootSibling;</span><br><span class="line">    <span class="keyword">while</span> ((rootSibling = container.lastChild)) &#123;</span><br><span class="line">      container.removeChild(rootSibling);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> isConcurrent = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ReactRoot(container, isConcurrent, shouldHydrate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断当前的 container 是否需要进行 forceHydrate，forceHydrate 为 false，则移除 container 下的所有子节点，然后标记 isConcurrent 为 false，实例化 ReactRoot；</p><ol start="3"><li>ReactRoot 的构造函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactRoot</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  container: Container,</span></span></span><br><span class="line"><span class="function"><span class="params">  isConcurrent: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrate: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> root = DOMRenderer.createContainer(container, isConcurrent, hydrate);</span><br><span class="line">  <span class="keyword">this</span>._internalRoot = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createContainer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  containerInfo: Container,</span></span></span><br><span class="line"><span class="function"><span class="params">  isConcurrent: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrate: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">OpaqueRoot</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createFiberRoot(containerInfo, isConcurrent, hydrate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 DOMRenderer.createContainer 创建一个 FiberRoot，并把当前的 FiberRoot 实例化对象记录到 root._internalRoot 中。</p><ol start="4"><li>ReactRoot 实例化对象 render 调用触发更新</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ReactRoot.prototype.render = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: ?(</span>) =&gt; <span class="title">mixed</span>,</span></span><br><span class="line"><span class="function">): <span class="title">Work</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> root = <span class="keyword">this</span>._internalRoot;</span><br><span class="line">  <span class="comment">// 创建一个 work</span></span><br><span class="line">  <span class="keyword">const</span> work = <span class="keyword">new</span> ReactWork();</span><br><span class="line">  callback = callback === <span class="literal">undefined</span> ? <span class="literal">null</span> : callback;</span><br><span class="line">  <span class="keyword">if</span> (callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 等待当前的 work 执行完成后执行回调函数</span></span><br><span class="line">    work.then(callback);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发更新</span></span><br><span class="line">  DOMRenderer.updateContainer(children, root, <span class="literal">null</span>, work._onCommit);</span><br><span class="line">  <span class="keyword">return</span> work;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateContainer</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  container: OpaqueRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  parentComponent: ?React$Component&lt;any, any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ExpirationTime</span> </span>&#123;</span><br><span class="line">  <span class="comment">// container 为当前的 FiberRoot 实例化对象</span></span><br><span class="line">  <span class="keyword">const</span> current = container.current;</span><br><span class="line">  <span class="comment">// 用于计算任务调度优先级</span></span><br><span class="line">  <span class="keyword">const</span> currentTime = requestCurrentTime();</span><br><span class="line">  <span class="keyword">const</span> expirationTime = computeExpirationForFiber(currentTime, current);</span><br><span class="line">  <span class="comment">// 推送和触发更新调度任务</span></span><br><span class="line">  <span class="keyword">return</span> updateContainerAtExpirationTime(</span><br><span class="line">    element,</span><br><span class="line">    container,</span><br><span class="line">    parentComponent,</span><br><span class="line">    expirationTime,</span><br><span class="line">    callback,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReactRoot 的原型方法 render 创建了一个 work，等待 work 执行完成后会执行 callback 的回调，而 work 的回调执行在于 wor._onCommit 的触发，render 方法最后调用了 DOMRenderer.updateContainer, updateContainer 这个方法一开进行 currentTime 和 expirationTime 来进行任务优先级的计算，然后执行 updateContainerAtExpirationTime 来进行渲染更新任务的触发。</p><ol start="5"><li>updateContainerAtExpirationTime 实现</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">updateContainerAtExpirationTime</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  container: OpaqueRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  parentComponent: ?React$Component&lt;any, any&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> current = container.current;</span><br><span class="line">  <span class="keyword">const</span> context = getContextForSubtree(parentComponent);</span><br><span class="line">  <span class="keyword">if</span> (container.context === <span class="literal">null</span>) &#123;</span><br><span class="line">    container.context = context;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    container.pendingContext = context;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> scheduleRootUpdate(current, element, expirationTime, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleRootUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactNodeList,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: ExpirationTime,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个 update 更新任务</span></span><br><span class="line">  <span class="keyword">const</span> update = createUpdate(expirationTime);</span><br><span class="line">  update.payload = &#123;element&#125;;</span><br><span class="line"></span><br><span class="line">  callback = callback === <span class="literal">undefined</span> ? <span class="literal">null</span> : callback;</span><br><span class="line">  <span class="keyword">if</span> (callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    warningWithoutStack(</span><br><span class="line">      <span class="keyword">typeof</span> callback === <span class="string">'function'</span>,</span><br><span class="line">      <span class="string">'render(...): Expected the last optional `callback` argument to be a '</span> +</span><br><span class="line">        <span class="string">'function. Instead received: %s.'</span>,</span><br><span class="line">      callback,</span><br><span class="line">    );</span><br><span class="line">    update.callback = callback;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把当前的更新任务和当前的 FiberRoot 压入任务队列</span></span><br><span class="line">  enqueueUpdate(current, update);</span><br><span class="line">  <span class="comment">// 触发任务队列进行任务执行</span></span><br><span class="line">  scheduleWork(current, expirationTime);</span><br><span class="line">  <span class="keyword">return</span> expirationTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>updateContainerAtExpirationTime 主要是执行 scheduleRootUpdate，scheduleRootUpdate 方法生成一个 update 更新任务，然后把当前的更新任务和当前的 FiberRoot 压入任务队列，接着触发任务队列进行任务执行。</p><p>到这里就完成了 ReactDOM render 的初始化，后续界面视图的更新渲染就依赖于 React 的 Fiber Schedule 进行更新调度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/react.jpg&quot; alt=&quot;banner&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;ReactDOM-render-用法&quot;&gt;&lt;a href=&quot;#ReactDOM-render-用法&quot; class=&quot;headerlink&quot; title=&quot;ReactD
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React下Hooks使用姿势</title>
    <link href="http://yoursite.com/2020/02/16/React%E4%B8%8BHooks%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/"/>
    <id>http://yoursite.com/2020/02/16/React下Hooks使用姿势/</id>
    <published>2020-02-16T12:52:09.000Z</published>
    <updated>2021-07-20T03:24:10.676Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/react-hooks.jpg" alt="banner"></p><blockquote><p>赋予函数组件拥有类组件的能力</p></blockquote><h2 id="State-Hook-使用"><a href="#State-Hook-使用" class="headerlink" title="State Hook 使用"></a>State Hook 使用</h2><p>用 Hooks 实现一个根据按钮点击计数的组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">'antd'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCount(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Button onClick=&#123;onButtonClick&#125;&gt;&#123;count&#125;&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Counter</span></span><br></pre></td></tr></table></figure><p>这里使用 useState 的 hook 实现在函数组件声明状态，当需要进行状态变更的时候，使用 useState 返回的 api 变更函数进行状态更新，一般回调函数的方式进行状态更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setCount(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>在 setCount 传入一个回调函数，这个回调函数会接收到当前 count 的最新状态值，接着回调函数通过 return 一个新的值从而进行状态更新。 </p><h2 id="Reducer-Hook-使用"><a href="#Reducer-Hook-使用" class="headerlink" title="Reducer Hook 使用"></a>Reducer Hook 使用</h2><p>useState 本身其实是基于 useReducer 进行实现的一个 hook。</p><p>我们看下 useReducer 的用法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">'antd'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> countReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'add'</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span> </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'sub'</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, dispatchCount] = useReducer(countReducer, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function">(<span class="params">type</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatchCount(&#123; type &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Button onClick=&#123;() =&gt; onButtonClick('add')&#125;&gt;Add&lt;/</span>Button&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; onButtonClick(<span class="string">'sub'</span>)&#125;&gt;Sub&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Counter</span><br></pre></td></tr></table></figure><p>定义一个 countReducer 函数, 通过不同的 action 参数来进行状态行为的变更，然后使用 useReducer 进行声明获得对应状态值 count，和变更触发方法 dispatchCount。</p><h2 id="Effect-Hook-使用"><a href="#Effect-Hook-使用" class="headerlink" title="Effect Hook 使用"></a>Effect Hook 使用</h2><p>当要在函数组件实现类似类组件的 componentDidMount， componentWillReceiveProps 的功能的时候，我们需要借助 useEffect 的 hook 来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [autoCount, setAutoCount] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setAutoCount(<span class="function"><span class="params">autoCount</span> =&gt;</span> autoCount + <span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123; clearInterval(timer) &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p&gt;AutoCount: &#123;autoCount&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Counter</span><br></pre></td></tr></table></figure><p>这个例子主要是在函数渲染后，通过 useEffect 的 hook 来实现一个自动计数的功能，useEffect 接收一个回调函数，用来进行当前的 effect hook 的响应操作，第二个参数为一个依赖的变量数组，当传入的依赖数组变量为空，则起到了类似 componentDidMount 的作用，在 useEffect 的回调函数值可以 return 一个函数用于处理当前的 effect hook 需要销毁的尾处理。</p><p>我们再举一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">'antd'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> countReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'add'</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span> </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'sub'</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, dispatchCount] = useReducer(countReducer, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> [full, setFull] = useState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function">(<span class="params">type</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatchCount(&#123; type &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    count &gt;= <span class="number">10</span> ? setFull(<span class="literal">true</span>) : setFull(<span class="literal">false</span>)</span><br><span class="line">  &#125;, [count])</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p&gt;Full: &#123;full ? <span class="string">'Full'</span> : <span class="string">'Not Full'</span>&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;&#123;count&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; onButtonClick(<span class="string">'add'</span>)&#125;&gt;Add&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Button onClick=&#123;() =&gt; onButtonClick('sub')&#125;&gt;Sub&lt;/</span>Button&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Counter</span></span><br></pre></td></tr></table></figure><p>这里例子主要是修改了上面 useReducer 所用到的例子，当 count 增加到 超过 10 的时候，useEffect 通过监听 count 的依赖变化，从而来判断并修改 full 的状态值，这里有点 vue 的 watch 的含义。</p><p>同样，我们也可以对 props 的参数传入到 useEffect 的依赖中，当 props 中的数据发生变化，可以触发 useEffect 的回调函数的执行，这样就起到了 componentWillReceiveProps 的作用。</p><h2 id="Context-Hooks-使用"><a href="#Context-Hooks-使用" class="headerlink" title="Context Hooks 使用"></a>Context Hooks 使用</h2><p>Context Hooks 目的是为了解决多层级组件的数据传递问题，通过 Context 的方式来中心化处理组件的数据更新，同时触发视图的渲染更新。</p><p>使用 Context Hooks 的方式如下：</p><p>Context 声明定义： context.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;createContext&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Context = createContext(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Context</span><br></pre></td></tr></table></figure><p>定义父组件：page-context.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Context <span class="keyword">from</span> <span class="string">'../components/context'</span></span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">'../components/counter'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Context.Provider value=<span class="string">"This is Counter"</span>&gt;</span><br><span class="line">        &lt;Counter&gt;&lt;<span class="regexp">/Counter&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Context.Provider&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App</span></span><br></pre></td></tr></table></figure><p>定义 Counter 子组件：counter.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useEffect, useState, useContext &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">'antd'</span></span><br><span class="line"><span class="keyword">import</span> Context <span class="keyword">from</span> <span class="string">'./context'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> countReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'add'</span>:</span><br><span class="line">      <span class="keyword">return</span> state + <span class="number">1</span> </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'sub'</span>:</span><br><span class="line">      <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, dispatchCount] = useReducer(countReducer, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> [full, setFull] = useState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> context = useContext(Context)</span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function">(<span class="params">type</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatchCount(&#123; type &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    count &gt;= <span class="number">10</span> ? setFull(<span class="literal">true</span>) : setFull(<span class="literal">false</span>)</span><br><span class="line">  &#125;, [count])</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p&gt;Context: &#123;context&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;Full: &#123;full ? 'Full' : 'Not Full'&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Button onClick=&#123;() =&gt; onButtonClick('add')&#125;&gt;Add&lt;/</span>Button&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; onButtonClick(<span class="string">'sub'</span>)&#125;&gt;Sub&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Counter</span><br></pre></td></tr></table></figure><p>使用 context 的主要方式是使用 createContext 定义一个上下文对象 Context，接着使用 Context 对象的 Provider 提供者这个属性，提供给到需要当前上下文的子组件。<br>在子组件中，使用 useContext 把 Context 对象传递进去，获得到对应的消费者并使用该消费者进行视图渲染或数据计算。</p><h2 id="Ref-Hook-使用"><a href="#Ref-Hook-使用" class="headerlink" title="Ref Hook 使用"></a>Ref Hook 使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">'antd'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef()</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ref.current)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Button ref=&#123;ref&#125; onClick=&#123;() =&gt; onButtonClick(<span class="string">'add'</span>)&#125;&gt;Add&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Counter</span><br></pre></td></tr></table></figure><p>使用 useRef 来声明获得当前的 ref 对象，赋值给对应的组件节点，ref.current 则表示为当前 ref 对应的组件的 dom 节点对象。</p><h2 id="Memo-Hooks-和-Callback-Hooks-使用"><a href="#Memo-Hooks-和-Callback-Hooks-使用" class="headerlink" title="Memo Hooks 和 Callback Hooks 使用"></a>Memo Hooks 和 Callback Hooks 使用</h2><p>官网对着两个 Hook 的解释如下</p><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedCallback = useCallback(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    doSomething(a, b);</span><br><span class="line">  &#125;,</span><br><span class="line">  [a, b],</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在传入的依赖值 a, b, 不变的情况下, memoizedCallback 的引用保持不变，useCallback 的第一个入参函数会被缓存。</p><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></figure><p>在传入的依赖值 a, b, 不变的情况下, memoizedValue 的值保持不变, useMemo函数的第一个入参函数不会被执行。</p><p>useCallback(fn, deps) 等价于 useMemo(() =&gt; fn, deps)</p><h3 id="useCallback-使用"><a href="#useCallback-使用" class="headerlink" title="useCallback 使用"></a>useCallback 使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useCallback &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> onCount = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> setCount(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>)</span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ChildComponent onCount=&#123;onCount&#125;&gt;&lt;/</span>ChildComponent&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Counter</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; memo &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">'antd'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ChildComponent = memo(<span class="function">(<span class="params">&#123; onCount &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;onCount&#125;</span>&gt;</span>Add<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为我们使用 useCallback 缓存了 onCount函数，使得当 count 发生变化时，Counter 重新渲染后 onCount 保持引用不变，传入 ChildComponent 借助 memo 方法使得 ChildComponent 组件避免了不必要的重新渲染。</p><h3 id="useMemo-使用"><a href="#useMemo-使用" class="headerlink" title="useMemo 使用"></a>useMemo 使用</h3><blockquote><p>useCallback 是根据传入的依赖,缓存第一个入参函数。useMemo 是根据传入的依赖，缓存第一个入参函数执行后的值。</p></blockquote><p>useMemo 个人理解与 vue 的 computed 属性类似</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useCallback, useMemo &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> onCount = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> setCount(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>)</span><br><span class="line">  &#125;, [])</span><br><span class="line">  <span class="keyword">const</span> couteComputed = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (count * <span class="number">1000</span>) / <span class="number">1024</span> </span><br><span class="line">  &#125;, [count]) </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;p&gt;&#123;count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;&#123;couteComputed&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;ChildComponent onCount=&#123;onCount&#125;&gt;&lt;<span class="regexp">/ChildComponent&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Counter</span><br></pre></td></tr></table></figure><p>useMemo 的依赖就可以只在指定变量值更改时才执行计算，从而达到节约内存消耗。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/react-hooks.jpg&quot; alt=&quot;banner&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;赋予函数组件拥有类组件的能力&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;State-Hook-使用&quot;&gt;&lt;a href=&quot;#St
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>从零开始打造属于自己的UI库</title>
    <link href="http://yoursite.com/2019/12/30/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%89%93%E9%80%A0%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84UI%E5%BA%93/"/>
    <id>http://yoursite.com/2019/12/30/从零开始打造属于自己的UI库/</id>
    <published>2019-12-30T11:44:01.000Z</published>
    <updated>2021-07-20T03:24:10.676Z</updated>
    
    <content type="html"><![CDATA[<p>目前主流的 Vue UI 框架很多, 每个 UI 框架的风格各有各的特点, 国内目前知名度较高的莫过于 Element 和 iView</p><p>大概是 16 年的时候，那时候刚开始上手 Vue2.0, 同时也分别使用了 Element 和 iView 两个 UI 框架来实现一些运营系统的前端开发。</p><p>从那时候开始就想着，能写出这么完善和优秀的框架得需要多久啊！内心一直很渴望也能够自己写一写 UI 框架，然后自己设计，自己配色。</p><p>不求推广到给别人使用！只求能够自己过把瘾！以及在写 UI 框架的过程中能够学习和沉淀多一丁点前端技术。</p><p><img src="/images/best-ui-banner.png" alt="Vue"></p><blockquote><p>The best-ui is not the best !important;</p></blockquote><p><strong>PS: Best UI 大部分学习和借鉴了 Element 和 iView 组件库的源码</strong></p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>+– build<br>+– examples<br>+– lib<br>+– packages<br>    +– components<br>    +– theme<br>+– src<br>    +– mixins<br>    +– utils<br>    +– index.js<br>+– tests<br>+– types<br>+– babel.config.js<br>+– components.json<br>+– gulpfile.js<br>+– package.json</p><p>看过 Element 的源码的同学估计一目了然，这里主要参考了 Element UI 的项目结构</p><p>简单讲一下这里的项目目录和文件的作用</p><ul><li>build              主要是和构建相关</li><li>examples           用于编写一些简单的 demo 代码，开发组件调试所用</li><li>lib                是打包构建完成后代码的存放目录</li><li>packages           是每个组件的源码实现, components 表示每个组件独立的目录，theme 存放组件的样式 .scss 文件</li><li>src                是 UI 框架的入口文件存放位置，以及一些工具函数，mixins，plugins 文件的存放</li><li>tests              单元测试和集成测试（不好意思，写这篇文章的时候一个组件的单元测试都还没写，我是个辣鸡）</li><li>types              d.ts 的类型声明文件（写这篇文章的时候所有组件的 d.ts 文件还没完成补齐，我是个辣鸡第二遍）</li><li>babel.config.js    babel 的配置声明</li><li>components.json    用来指定具体组件的源码位置，用于构建多个组件单独的文件</li><li>gulpfile           用于 gulp 进行样式构建的运行文件</li></ul><p>一个前端工程化项目的结构出来了，按照个人的开发习惯，接下来就是要对项目的构建进行配置了，不然光写代码而运行不了，没什么意义。</p><h2 id="构建过程配置"><a href="#构建过程配置" class="headerlink" title="构建过程配置"></a>构建过程配置</h2><p><img src="/images/webpack-logo.jpeg" alt="Webpack]"></p><p>对于 Webpack 的配置，本来一开始是使用 vue-cli 来生成对应的构建配置，但是后面发现要去修改适配组件库的构建流程有点鸡肋，所以就干脆自己大致按照 Element 的方式去做一遍配置，每个环节这里都会详细介绍</p><p>build 这个构建配置的目录如下：</p><p>+– build<br>    +– bin<br>        +– build-component.js<br>        +– build.js<br>        +– watch.js<br>    +– utils<br>    +– config.js<br>    +– webpack.base.js<br>    +– webpack.build.js<br>    +– webpack.component.js<br>    +– webpack.watch.js</p><p>bin 目录三个文件代表了三个运行的命令</p><ul><li>build-component  主要是用于构建多个组件的单文件。</li><li>build            表示构建整体的组件库，包含多个组件的合并。</li><li>watch            用于开发构建过程中预览调试</li></ul><p>utils 中只有一个 resolve 用来做路径的解析</p><h3 id="Webpack-的-Base-配置"><a href="#Webpack-的-Base-配置" class="headerlink" title="Webpack 的 Base 配置"></a>Webpack 的 Base 配置</h3><p>webpack.base.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>)</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>)</span><br><span class="line"><span class="keyword">const</span> happyThreadPool = HappyPack.ThreadPool(&#123; <span class="attr">size</span>: os.cpus().length &#125;)</span><br><span class="line"><span class="keyword">const</span> &#123; VueLoaderPlugin &#125; = <span class="built_in">require</span>(<span class="string">'vue-loader'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'./utils/resolve'</span>)</span><br><span class="line"><span class="keyword">const</span> ProgressBarPlugin = <span class="built_in">require</span>(<span class="string">'progress-bar-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">'.vue'</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'@'</span>: resolve(process.cwd(), <span class="string">'examples'</span>),</span><br><span class="line">      <span class="string">'~'</span>: resolve(process.cwd(), <span class="string">'packages'</span>),</span><br><span class="line">      src: resolve(process.cwd(), <span class="string">'src'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        loader: <span class="string">'happypack/loader?id=eslint'</span>,</span><br><span class="line">        enforce: <span class="string">'pre'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        loader: <span class="string">'happypack/loader?id=babel'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        loader: <span class="string">'vue-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          loader: &#123;</span><br><span class="line">            js: <span class="string">'happypack/loader?id=babel'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">          <span class="string">'sass-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/</span>,</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: <span class="number">10000</span>,</span><br><span class="line">          name: <span class="string">'fonts/[name].[hash:7].[ext]'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      id: <span class="string">'eslint'</span>,</span><br><span class="line">      loaders: [&#123;</span><br><span class="line">        loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          formatter: <span class="built_in">require</span>(<span class="string">'eslint-friendly-formatter'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;],</span><br><span class="line">      verbose: <span class="literal">false</span>,</span><br><span class="line">      threadPool: happyThreadPool</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      id: <span class="string">'babel'</span>,</span><br><span class="line">      loaders: [&#123;</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          cacheDirectory: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;],</span><br><span class="line">      verbose: <span class="literal">false</span>,</span><br><span class="line">      threadPool: happyThreadPool</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> ProgressBarPlugin(),</span><br><span class="line">    <span class="keyword">new</span> VueLoaderPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 happypack 来进行 babel 的转码，配置对应需要的 loader 和 plugins</p><p>配置 resolve.alisa 对一些常用的目录文件路径进行缩写配置</p><p>这里没有指定 entry 和 output 主要是让其他的环境配置进行指定</p><h3 id="Watch-模式"><a href="#Watch-模式" class="headerlink" title="Watch 模式"></a>Watch 模式</h3><p>webpack.base.js: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> baseConf = <span class="built_in">require</span>(<span class="string">'./webpack.base'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = merge(baseConf, &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./examples/main.js'</span>,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./examples/template/index.html'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config</span><br></pre></td></tr></table></figure><p>bin/watch.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../webpack.watch'</span>)</span><br><span class="line"><span class="keyword">const</span> middleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compiler = webpack(config)</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.use(</span><br><span class="line">  middleware(compiler, &#123;</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Example app listening on port 3000!'</span>))</span><br></pre></td></tr></table></figure><p>Watch 模式下使用 webpack-dev-middleware 结合 express 实现一个简单的 dev-server 进行开发预览，对应的入口文件为我们 examples 下的 main.js 文件。</p><h3 id="build-模式"><a href="#build-模式" class="headerlink" title="build 模式"></a>build 模式</h3><p>webpack.build.js: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">const</span> baseConf = <span class="built_in">require</span>(<span class="string">'./webpack.base'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; externals &#125; = <span class="built_in">require</span>(<span class="string">'./config'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'./utils/resolve'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = merge(baseConf, &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: resolve(process.cwd(), <span class="string">'src'</span>, <span class="string">'index.js'</span>),</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: resolve(process.cwd(), <span class="string">'./lib'</span>),</span><br><span class="line">    publicPath: <span class="string">'/dist/'</span>,</span><br><span class="line">    filename: <span class="string">'index.js'</span>,</span><br><span class="line">    library: <span class="string">'BEST'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'umd'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  performance: &#123;</span><br><span class="line">    hints: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  externals,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config</span><br></pre></td></tr></table></figure><p>指定 mode 为 production，配置对应的 entry 为 src 下的 index.js ， 用于进行全局构建，对应的 output 路径为 lib，指定的 libraryTarget 为 umd 模块。</p><p>bin/build.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../webpack.build'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compiler = webpack(config)</span><br><span class="line"></span><br><span class="line">compiler.run(<span class="function"><span class="keyword">function</span> (<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.error(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>直接借助 webapck 的 compiler 执行构建</p><h3 id="Build-Component-模式"><a href="#Build-Component-模式" class="headerlink" title="Build Component 模式"></a>Build Component 模式</h3><p>这里说明一下为什么要构建单个的组件文件，因为涉及到 <strong>按需加载</strong> 的使用，我们需要对单个的组件进行构建，这里可以借助 webpack 的多文件构建模式来执行</p><p>webapck.component.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">const</span> baseConf = <span class="built_in">require</span>(<span class="string">'./webpack.base'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; externals &#125; = <span class="built_in">require</span>(<span class="string">'./config'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'./utils/resolve'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> components = <span class="built_in">require</span>(<span class="string">'../components.json'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> entrys = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(components).forEach(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">  entrys[component] = components[component]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = merge(baseConf, &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: entrys,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: resolve(process.cwd(), <span class="string">'lib'</span>),</span><br><span class="line">    publicPath: <span class="string">'/dist/'</span>,</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'commonjs2'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  performance: &#123;</span><br><span class="line">    hints: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  externals</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config</span><br></pre></td></tr></table></figure><p>通过读取 component.json 的配置文件来获取构建的组件对应的入口文件路径，对应的 output 路径为 lib</p><h3 id="样式构建"><a href="#样式构建" class="headerlink" title="样式构建"></a>样式构建</h3><p><img src="/images/gulp-logo.jpg" alt="Gulp]"></p><p>Best UI 组件库是用 Sass 来进行样式的编写，我们这里为了和 js 的构建区分开，所以在样式的构建上，单独使用 gulp 对 .scss 的样式文件进行构建</p><p>gulpfile.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; series, src, dest &#125; = <span class="built_in">require</span>(<span class="string">'gulp'</span>)</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>)</span><br><span class="line"><span class="keyword">const</span> autoprefixer = <span class="built_in">require</span>(<span class="string">'gulp-autoprefixer'</span>)</span><br><span class="line"><span class="keyword">const</span> cssmin = <span class="built_in">require</span>(<span class="string">'gulp-cssmin'</span>)</span><br><span class="line"><span class="keyword">const</span> basepath = <span class="string">'./packages/theme'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compile</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> src(<span class="string">`<span class="subst">$&#123;basepath&#125;</span>/src/*.scss`</span>)</span><br><span class="line">    .pipe(sass.sync())</span><br><span class="line">    .pipe(autoprefixer(&#123;</span><br><span class="line">      cascade: <span class="literal">false</span></span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(cssmin())</span><br><span class="line">    .pipe(dest(<span class="string">'./lib/theme'</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyfont</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> src(<span class="string">`<span class="subst">$&#123;basepath&#125;</span>/src/fonts/**`</span>)</span><br><span class="line">    .pipe(cssmin())</span><br><span class="line">    .pipe(dest(<span class="string">'./lib/theme/fonts'</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.build = series(compile, copyfont)</span><br></pre></td></tr></table></figure><p>这里沿用了 Element 的 gulpfile。这个 gulp 的构建过程很简单，主要做两件事情：</p><ul><li>将 packages/theme/src 下的每个 .scss 和 .css 的文件进行编译，压缩，最后输出到 lib/theme 的目录下</li><li>将 packages/theme/src 下的字体文件进行压缩并输出到 lib/theme/fonts 的目录下</li></ul><h3 id="package-json-的-script-配置"><a href="#package-json-的-script-配置" class="headerlink" title="package.json 的 script 配置"></a>package.json 的 script 配置</h3><p>通过以上完成了对应的构建配置，为了快速执行以上的命令，我们可以在 npm 的 script 中进行配置:</p><p>package.json:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"watch"</span>: <span class="string">"node ./build/bin/watch.js"</span>,</span><br><span class="line">    <span class="attr">"build:component"</span>: <span class="string">"node ./build/bin/build-component.js"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"node ./build/bin/build.js"</span>,</span><br><span class="line">    <span class="attr">"build:all"</span>: <span class="string">"npm run build &amp; npm run build:component &amp; npm run build:css"</span>,</span><br><span class="line">    <span class="attr">"build:css"</span>: <span class="string">"gulp build --gulpfile ./gulpfile.js"</span>,</span><br><span class="line">    <span class="attr">"lint"</span>: <span class="string">"eslint --fix --ext .js,.vue src packages"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尝试开发一个组件"><a href="#尝试开发一个组件" class="headerlink" title="尝试开发一个组件"></a>尝试开发一个组件</h2><p><img src="/images/vue-logo.png" alt="Vue"></p><p>以上已经完成了对整个构建过程的配置，当我们把必要的工程化工具都配置好了后，可以尝试上手开发一个组件，我们以开发一个 Button 组件为具体实例</p><h3 id="组件交互逻辑开发"><a href="#组件交互逻辑开发" class="headerlink" title="组件交互逻辑开发"></a>组件交互逻辑开发</h3><p>在 package 的目录下新建一个 button 的目录，然后新建以下的文件：</p><p>button/index.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BTButton <span class="keyword">from</span> <span class="string">'./src/button'</span></span><br><span class="line"></span><br><span class="line">BTButton.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  Vue.component(BTButton.name, BTButton)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> BTButton</span><br></pre></td></tr></table></figure><p>index.js 作为 button 组件的入口文件，这里给 BTButton 定义 install 方法，目的是方便通过 vue 的插件形式进行全局组件注册。</p><p>组件的逻辑实现在 button/src/button.vue:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:disabled</span>=<span class="string">"disabled"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">"button"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:class</span>=<span class="string">"[</span></span></span><br><span class="line"><span class="tag"><span class="string">      'bt-button',</span></span></span><br><span class="line"><span class="tag"><span class="string">      type ? `bt-button--$&#123;type&#125;` : '',</span></span></span><br><span class="line"><span class="tag"><span class="string">      &#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">        'is-circle': circle,</span></span></span><br><span class="line"><span class="tag"><span class="string">        'is-disabled': disabled</span></span></span><br><span class="line"><span class="tag"><span class="string">      &#125;</span></span></span><br><span class="line"><span class="tag"><span class="string">    ]"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">click</span>=<span class="string">"handleClick"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">:class</span>=<span class="string">"icon"</span> <span class="attr">v-if</span>=<span class="string">"icon"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">"$slots.default"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- @slot 默认插槽 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">/**</span><br><span class="line"> * Button 按钮</span><br><span class="line"> * @displayName Best Button</span><br><span class="line"> */</span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  name: <span class="string">'BtButton'</span>,</span></span><br><span class="line"></span><br><span class="line">  props: &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 类型</span><br><span class="line"><span class="javascript">     * <span class="string">`default,primary,info,warn`</span></span></span><br><span class="line">     */</span><br><span class="line">    type: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="string">'default'</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    /**</span><br><span class="line">     * 是否圆形按钮</span><br><span class="line">     */</span><br><span class="line">    circle: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">Boolean</span>,</span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="literal">false</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    /**</span><br><span class="line">     * 图标类名</span><br><span class="line">     */</span><br><span class="line">    icon: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="string">''</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    /**</span><br><span class="line">     * 是否禁用</span><br><span class="line">     */</span><br><span class="line">    disabled: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">Boolean</span>,</span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="literal">false</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Click 事件</span><br><span class="line">     *</span><br><span class="line">     * @event click</span><br><span class="line">     * @type &#123;object&#125;</span><br><span class="line">     */</span><br><span class="line">    handleClick (event) &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.$emit(<span class="string">'click'</span>, event)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>button 的组件实现并不复杂，这里用一个很简单的例子来说明添加一个组件开发的过程（牛x的同学可以考虑打造 cli 来快速新建一个组件的模板）</p><h3 id="将组件添加到全局入口文件和配置文件"><a href="#将组件添加到全局入口文件和配置文件" class="headerlink" title="将组件添加到全局入口文件和配置文件"></a>将组件添加到全局入口文件和配置文件</h3><p>我们将我们开发完的 button 组件注册到 src/index.js 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">'~/button'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> components = [</span><br><span class="line">  Button,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue, opts = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  components.forEach(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">    Vue.component(component.name, component)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install,</span><br><span class="line">  Button,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将开发完成的 button 组件注册到全局的入口文件，提供全量引入的方式。</p><p>对于组件的配置文件 componets.json:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"button"</span>: <span class="string">"./packages/button"</span>,</span><br><span class="line">  <span class="attr">"best-ui.common"</span>: <span class="string">"./src"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置 webapck 在构建多个组件文件的过程中每个组件文件对应 entry 的路径 和 output 的文件名。</p><h3 id="编写-d-ts-类型声明文件"><a href="#编写-d-ts-类型声明文件" class="headerlink" title="编写 d.ts 类型声明文件"></a>编写 d.ts 类型声明文件</h3><p>types/button.d.ts:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BestUIComponent &#125; <span class="keyword">from</span> <span class="string">'./components'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> ButtonType = <span class="string">'default'</span> | <span class="string">'primary'</span> | <span class="string">'info'</span> | <span class="string">'warn'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">class</span> BTButton <span class="keyword">extends</span> BestUIComponent &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">type</span>?: ButtonType</span><br><span class="line"></span><br><span class="line">  circle?: <span class="built_in">boolean</span></span><br><span class="line">  </span><br><span class="line">  icon?: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  disabled?: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>types/components.d.ts:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">declare</span> <span class="keyword">class</span> BestUIComponent <span class="keyword">extends</span> Vue &#123;</span><br><span class="line">  <span class="keyword">static</span> install (vue: <span class="keyword">typeof</span> Vue): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写单元测试"><a href="#编写单元测试" class="headerlink" title="编写单元测试"></a>编写单元测试</h3><p>待补充 !-_-!</p><h2 id="组件样式开发"><a href="#组件样式开发" class="headerlink" title="组件样式开发"></a>组件样式开发</h2><p><img src="/images/sass-logo.png" alt="Vue"></p><h3 id="BEM-样式编写规范"><a href="#BEM-样式编写规范" class="headerlink" title="BEM 样式编写规范"></a>BEM 样式编写规范</h3><blockquote><p>BEM代表 “块（block）, 元素（element）, 修饰符（modifier）”</p></blockquote><p>以 Button 的组件为例子，我们看下怎么理解 BEM 的规范</p><p>对于 Best UI， 前缀统一使用 bt 进行命名，所以 button 组件在 Best UI 的样式命名 为 bt-button，这里 bt-button 表示一个 block</p><p>当 bt-button 下有其他的关联元素，比如标签，这时候可以命名为 bt-button__label</p><p>通常一个 button 有不同的修饰类型，一个 button 可以为 primary 类型，也可以为 info 类型，或者 warning 类型，这种就可以用修饰符来命名 bt-button–primary</p><p>我们看下 packages/theme/button.scss 的实现</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@charset</span> <span class="string">"UTF-8"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"common/var"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"mixins/_button"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"mixins/mixins"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"mixins/utils"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@include</span> b(button) &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">  <span class="attribute">background</span>: <span class="variable">$--button-default-background-color</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">$--border-base</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="variable">$--button-default-border-color</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$--button-default-font-color</span>;</span><br><span class="line">  -webkit-appearance: none;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="variable">$--button-box-shadow</span>;</span><br><span class="line">  <span class="attribute">outline</span>: none;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="variable">$--button-font-weight</span>;</span><br><span class="line">  <span class="attribute">transition</span>: .<span class="number">1s</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@include</span> utils-user-select(none);</span><br><span class="line">  </span><br><span class="line">  &amp; + &amp; &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@include</span> button-size(<span class="variable">$--button-padding-vertical</span>, <span class="variable">$--button-padding-horizontal</span>, <span class="variable">$--button-font-size</span>, <span class="variable">$--button-border-radius</span>);</span><br><span class="line"></span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span>,</span><br><span class="line">  &amp;<span class="selector-pseudo">:focus</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$--color-primary</span>;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="variable">$--color-primary-light-7</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="variable">$--color-primary-light-9</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="variable">$--button-modifier-box-shadow</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &amp;<span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: mix(<span class="variable">$--color-black</span>, <span class="variable">$--color-primary</span>, <span class="variable">$--button-active-shade-percent</span>);</span><br><span class="line">    <span class="attribute">border-color</span>: mix(<span class="variable">$--color-black</span>, <span class="variable">$--color-primary</span>, <span class="variable">$--button-active-shade-percent</span>);</span><br><span class="line">    <span class="attribute">outline</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@include</span> when(circle) &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="variable">$--border-radius-circle</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">    &amp; &gt; * &#123;</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="variable">$--button-font-size</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@include</span> m(primary) &#123;</span><br><span class="line">    <span class="keyword">@include</span> button-variant(<span class="variable">$--button-primary-font-color</span>, <span class="variable">$--button-primary-background-color</span>, <span class="variable">$--button-primary-border-color</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@include</span> m(info) &#123;</span><br><span class="line">    <span class="keyword">@include</span> button-variant(<span class="variable">$--button-info-font-color</span>, <span class="variable">$--button-info-background-color</span>, <span class="variable">$--button-info-border-color</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@include</span> m(warn) &#123;</span><br><span class="line">    <span class="keyword">@include</span> button-variant(<span class="variable">$--button-warn-font-color</span>, <span class="variable">$--button-warn-background-color</span>, <span class="variable">$--button-warn-border-color</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里咋一看，可能会觉得这 sass 写得也太复杂了吧！笔者一开始看 Element 的时候就有这种感觉，因为这里都是参考了 Element 的规范，我们这里对这里的 sass 写法做一些详细分析。</p><h3 id="Sass-公用方法分析"><a href="#Sass-公用方法分析" class="headerlink" title="Sass 公用方法分析"></a>Sass 公用方法分析</h3><p>(1) common/var.scss 这个文件主要是对一些颜色，字体大小，边框等等样式变量进行定义，方便主题的统一修改替换</p><p>(2) 对于 mixins/utils.scss 这个主要是一些工具的 sass 函数，比如：清除浮动，文字溢出处理，垂直居中等等</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> utils-user-select(<span class="variable">$value</span>) &#123;</span><br><span class="line">  -moz-user-<span class="selector-tag">select</span>: <span class="variable">$value</span>;</span><br><span class="line">  -webkit-user-<span class="selector-tag">select</span>: <span class="variable">$value</span>;</span><br><span class="line">  -ms-user-<span class="selector-tag">select</span>: <span class="variable">$value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> utils-clearfix &#123;</span><br><span class="line">  <span class="variable">$selector</span>: &amp;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@at-root</span> &#123;</span><br><span class="line">    #&#123;<span class="variable">$selector</span>&#125;<span class="selector-pseudo">::before</span>,</span><br><span class="line">    #&#123;<span class="variable">$selector</span>&#125;<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">      <span class="attribute">display</span>: table;</span><br><span class="line">      <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    #&#123;<span class="variable">$selector</span>&#125;<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">      <span class="attribute">clear</span>: both;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> utils-vertical-center &#123;</span><br><span class="line">  <span class="variable">$selector</span>: &amp;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@at-root</span> &#123;</span><br><span class="line">    #&#123;<span class="variable">$selector</span>&#125;<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">      <span class="attribute">display</span>: inline-block;</span><br><span class="line">      <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">      <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> utils-ellipsis &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3) 我们重点看下 mixins/mixins.scss</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">"function"</span>; <span class="comment">/* 配置 $namespace, $element-separator, $modifier-separator, $state-prefix */</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">"../common/var"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* BEM */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// block</span></span><br><span class="line"><span class="keyword">@mixin</span> b(<span class="variable">$block</span>) &#123;</span><br><span class="line">  <span class="variable">$B</span>: <span class="variable">$namespace</span>+<span class="string">'-'</span>+<span class="variable">$block</span> !global; <span class="comment">// $B is the global var</span></span><br><span class="line"></span><br><span class="line">  .#&#123;<span class="variable">$B</span>&#125; &#123;</span><br><span class="line">    <span class="keyword">@content</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// element</span></span><br><span class="line"><span class="keyword">@mixin</span> e(<span class="variable">$element</span>) &#123;</span><br><span class="line">  <span class="variable">$E</span>: <span class="variable">$element</span> !global; <span class="comment">// $E is the global var</span></span><br><span class="line">  <span class="variable">$selector</span>: &amp;;</span><br><span class="line">  <span class="variable">$currentSelector</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">@each</span> <span class="variable">$unit</span> in <span class="variable">$element</span> &#123;</span><br><span class="line">    <span class="variable">$currentSelector</span>: #&#123;<span class="variable">$currentSelector</span> + <span class="string">"."</span> + <span class="variable">$B</span> + <span class="variable">$element-separator</span> + <span class="variable">$unit</span> + <span class="string">","</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@if</span> hitAllSpecialNestRule(<span class="variable">$selector</span>) &#123;</span><br><span class="line">    <span class="keyword">@at-root</span> &#123;</span><br><span class="line">      #&#123;<span class="variable">$selector</span>&#125; &#123;</span><br><span class="line">        #&#123;<span class="variable">$currentSelector</span>&#125; &#123;</span><br><span class="line">          <span class="keyword">@content</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">    <span class="keyword">@at-root</span> &#123;</span><br><span class="line">      #&#123;<span class="variable">$currentSelector</span>&#125; &#123;</span><br><span class="line">        <span class="keyword">@content</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// modifier</span></span><br><span class="line"><span class="keyword">@mixin</span> m(<span class="variable">$modifier</span>) &#123;</span><br><span class="line">  <span class="variable">$selector</span>: &amp;;</span><br><span class="line">  <span class="variable">$currentSelector</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">@each</span> <span class="variable">$unit</span> in <span class="variable">$modifier</span> &#123;</span><br><span class="line">    <span class="variable">$currentSelector</span>: #&#123;<span class="variable">$currentSelector</span> + &amp; + <span class="variable">$modifier-separator</span> + <span class="variable">$unit</span> + <span class="string">","</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@at-root</span> &#123;</span><br><span class="line">    #&#123;<span class="variable">$currentSelector</span>&#125; &#123;</span><br><span class="line">      <span class="keyword">@content</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> when(<span class="variable">$state</span>) &#123;</span><br><span class="line">  <span class="keyword">@at-root</span> &#123;</span><br><span class="line">    &amp;.#&#123;<span class="variable">$state-prefix</span> + <span class="variable">$state</span>&#125; &#123;</span><br><span class="line">      <span class="keyword">@content</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 b 函数，e 函数，m 函数，when 函数分别用于对类名进行封装</p><p>比如我们要对 button 命名一个 bt-button，这时候可以用</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@include</span> b(button) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要命名 bt-button__label，则写法如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@include</span> b(button) &#123;</span><br><span class="line">  <span class="keyword">@include</span> e(label) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要对 bt-button 进行修饰得到 bt-button–primary 的时候：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@include</span> b(button) &#123;</span><br><span class="line">  <span class="keyword">@include</span> m(primary) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要标识状态的类名可以使用 when 函数，比如：是否为圆形按钮，is-circle</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@include</span> b(button) &#123;</span><br><span class="line">  <span class="keyword">@include</span> when(circle) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式高效利用 sass 的强大语法，结合 BEM 的规范让我们书写样式的时候井然有序，简洁明了（前提是已经了解 sass 的语法）。</p><h2 id="Vue-组件开发技巧"><a href="#Vue-组件开发技巧" class="headerlink" title="Vue 组件开发技巧"></a>Vue 组件开发技巧</h2><p>使用 Vue 框架实现一个组件库，不像我们平时在业务层级可以引入一些库比如 vuex，vue-router。我们需要追求更加简洁，尽量确保不引入多余的库。</p><h3 id="跨层级的组件通信"><a href="#跨层级的组件通信" class="headerlink" title="跨层级的组件通信"></a>跨层级的组件通信</h3><p>假如我们有 A 组件，然后 A 组件可以通过 slot 插槽嵌入 B 组件，B 组件又可以通过 slot 嵌入 C 组件，这时候 C 组件想向 A 组件进行跨级通信简单通过 props 和 emit 要传递可能会显得比较繁琐。</p><p>于是，我们可以自己实现一个 dispatch 和 broadcast 的功能</p><p><strong>PS: 这里主要参考 iView 的实现</strong></p><p>src/mixins/emitter.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@desc </span>向上遍历找寻对应组件名称的父组件分发事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">componentName</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">eventName</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">params</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dispatch (componentName, eventName, params) &#123;</span><br><span class="line">      <span class="keyword">let</span> parent = <span class="keyword">this</span>.$parent || <span class="keyword">this</span>.$root</span><br><span class="line">      <span class="keyword">let</span> name = parent.$options.name</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (parent &amp;&amp; (!name || name !== componentName)) &#123;</span><br><span class="line">        parent = parent.$parent</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">          name = parent.$options.name</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">        parent.$emit(eventName, params)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@desc </span>向下便利找寻对应组件名称的子组件分发事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">componentName</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">eventName</span></span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">params</span></span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    broadcast (componentName, eventName, params) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> name = child.$options.name</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name === componentName) &#123;</span><br><span class="line">          child.$emit(eventName, params)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.broadcast.apply(child, [componentName, eventName, params])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们的 C 组件需要向 A 组件进行通信的时候，我们这时候可以使用 dispatch，在 C 组件中向上寻找 A 组件，通过 name 属性找到 A 组件，然后传递对应的事件名称和参数。</p><p>当我们 A 组件需要向 C 组件进行通信，我们可以使用 broadcast 广播向下寻找 C 组件，并通知对应的事件和参数。</p><h3 id="其他技巧等待缓慢补充"><a href="#其他技巧等待缓慢补充" class="headerlink" title="其他技巧等待缓慢补充"></a>其他技巧等待缓慢补充</h3><p>待补充 !-_-!</p><h2 id="发布-Best-UI"><a href="#发布-Best-UI" class="headerlink" title="发布 Best UI"></a>发布 Best UI</h2><p>完成了以上的分析，这时候 Best UI 的大概的结构和实现已经出来了，那我们怎么去发布我们的库呢？</p><p>其实很简单，只要我们配置好对应的 package.json 文件就 ok 了</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"@douku/best-ui"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.5"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"lib/best-ui.common.js"</span>,</span><br><span class="line">  <span class="attr">"files"</span>: [</span><br><span class="line">    <span class="string">"lib"</span>,</span><br><span class="line">    <span class="string">"src"</span>,</span><br><span class="line">    <span class="string">"packages"</span>,</span><br><span class="line">    <span class="string">"types"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"typings"</span>: <span class="string">"types/index.d.ts"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"watch"</span>: <span class="string">"node ./build/bin/watch.js"</span>,</span><br><span class="line">    <span class="attr">"build:component"</span>: <span class="string">"node ./build/bin/build-component.js"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"node ./build/bin/build.js"</span>,</span><br><span class="line">    <span class="attr">"build:all"</span>: <span class="string">"npm run build &amp; npm run build:component &amp; npm run build:css"</span>,</span><br><span class="line">    <span class="attr">"build:css"</span>: <span class="string">"gulp build --gulpfile ./gulpfile.js"</span>,</span><br><span class="line">    <span class="attr">"lint"</span>: <span class="string">"eslint --fix --ext .js,.vue src packages"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"repository"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"git"</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"git@github.com:DouKu/best-ui.git"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [</span><br><span class="line">    <span class="string">"best"</span>,</span><br><span class="line">    <span class="string">"vue"</span>,</span><br><span class="line">    <span class="string">"components"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"bugs"</span>: &#123;</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"https://github.com/DouKu/best-ui/issues"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"MIT"</span>,</span><br><span class="line">  <span class="attr">"unpkg"</span>: <span class="string">"lib/index.js"</span>,</span><br><span class="line">  <span class="attr">"style"</span>: <span class="string">"lib/theme/index.css"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"async-validator"</span>: <span class="string">"^3.1.0"</span>,</span><br><span class="line">    <span class="attr">"vue"</span>: <span class="string">"^2.6.10"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"peerDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"vue"</span>: <span class="string">"^2.6.10"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"husky"</span>: &#123;</span><br><span class="line">    <span class="attr">"hooks"</span>: &#123;</span><br><span class="line">      <span class="attr">"pre-commit"</span>: <span class="string">"npm run lint"</span>,</span><br><span class="line">      <span class="attr">"pre-push"</span>: <span class="string">"npm run lint"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>name: 组件库的包名称</li><li>main: 全局加载的入口文件</li><li>files: 需要发布的文件列表</li><li>typings: 类型声明文件位置</li><li>peerDependencies: 这里简单来说就是如果你安装了 best-ui, 那你最好也安装 vue</li></ul><h2 id="使用-Best-UI"><a href="#使用-Best-UI" class="headerlink" title="使用 Best UI"></a>使用 Best UI</h2><h3 id="全局引入"><a href="#全局引入" class="headerlink" title="全局引入"></a>全局引入</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> BestUI <span class="keyword">from</span> <span class="string">'@douku/best-ui'</span>; </span><br><span class="line"><span class="keyword">import</span> <span class="string">'@douku/best-ui/lib/theme/index.css'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(BestUI);</span><br></pre></td></tr></table></figure><h3 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h3><p>.babelrc:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"component"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"libraryName"</span>: <span class="string">"@douku/best-ui"</span>,</span><br><span class="line">        <span class="attr">"styleLibraryName"</span>: <span class="string">"theme"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>js 使用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">'@douku/best-ui'</span>;</span><br><span class="line"></span><br><span class="line">Vue.component(Button.name, Button);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里简单说一下 babel-plugins-component 实现按需加载的原理, 其实就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Button &#125; <span class="keyword">from</span> <span class="string">'@douku/best-ui'</span>;</span><br></pre></td></tr></table></figure><p>转换为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="built_in">require</span>(<span class="string">'@douku/best-ui/lib/button.js'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'@douku/best-ui/lib/theme/button.css'</span>);</span><br></pre></td></tr></table></figure><p>这样就不难理解为什么能过实现按需加载了!</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>今天是 2019 的最后一天了，回看博客，今年自己写的文章比去年多了一些，希望明年能写出更多。</p><p>保持热爱前端的态度，不断折腾，追求极致!</p><p>源码地址：<a href="https://github.com/DouKu/best-ui" target="_blank" rel="noopener">Best UI</a></p><p>半成品文档地址：<a href="https://best-ui.github.io/zh/components/common/button.html" target="_blank" rel="noopener">Best UI</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前主流的 Vue UI 框架很多, 每个 UI 框架的风格各有各的特点, 国内目前知名度较高的莫过于 Element 和 iView&lt;/p&gt;
&lt;p&gt;大概是 16 年的时候，那时候刚开始上手 Vue2.0, 同时也分别使用了 Element 和 iView 两个 UI 框架
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码解析之Watcher原理</title>
    <link href="http://yoursite.com/2019/07/28/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BWatcher%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/07/28/Vue源码解析之Watcher原理/</id>
    <published>2019-07-28T13:11:31.000Z</published>
    <updated>2021-07-20T03:24:10.676Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vue-logo.png" alt="Vue"></p><p>对于用户定义的 Watche 属性官方描述如下:</p><blockquote><p>一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。</p></blockquote><p>接着看下文档对 $watch 的用法描述:</p><blockquote><p>观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。</p></blockquote><h2 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h2><p>挺久没更新文章了, 回顾一下 Vue 的 initState 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options</span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 响应式处理</span></span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Vue 实例化执行 _init 的时候执行 initState, 这时候 initState 执行 initWatch 把 vm 实例和 opts 选项参数中的 watch 属性传递给 initWatch 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initWatch</span> (<span class="params">vm: Component, watch: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> watch) &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = watch[key]</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(handler)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class="line">        createWatcher(vm, key, handler[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      createWatcher(vm, key, handler)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initWatch 方法其实就是遍历用户定义的 watch 属性, 接着调用 createWatcher 进行 User Watcher 的创建</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWatcher</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  expOrFn: string | Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  handler: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: Object</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(handler)) &#123;</span><br><span class="line">    options = handler</span><br><span class="line">    handler = handler.handler</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">'string'</span>) &#123;</span><br><span class="line">    handler = vm[handler]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm.$watch(expOrFn, handler, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createWatcher 其实就是调用 vm 实例的 $watch 方法, $watch 方法我们刚才从官方文档的描述中可以知道, 就是观察 Vue 实例变化的一个表达式或计算属性函数。</p><p>$watch 是在执行 stateMixin 的时候定义在 Vue 的原型方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  expOrFn: string | Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  cb: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: Object</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(cb)) &#123;</span><br><span class="line">    <span class="keyword">return</span> createWatcher(vm, expOrFn, cb, options)</span><br><span class="line">  &#125;</span><br><span class="line">  options = options || &#123;&#125;</span><br><span class="line">  options.user = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options)</span><br><span class="line">  <span class="keyword">if</span> (options.immediate) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      cb.call(vm, watcher.value)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      handleError(error, vm, <span class="string">`callback for immediate watcher "<span class="subst">$&#123;watcher.expression&#125;</span>"`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    watcher.teardown()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 $watch 的实现可以看出 </p><ul><li><p>options.user = true, 表明这是一个 user watcher, 本质上也是通过 new Watcher 来实例化得到一个 user watcher. </p></li><li><p>当 options.immediate 为 true, 则会在实例化当前的 user watcher 后立即调用执行 cb 函数, 也就是用户定义的数据变化响应执行函数. 最后会返回一个取消观察函数，用来停止触发回调。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var unwatch = vm.$watch(&apos;a&apos;, cb)</span><br><span class="line">// 之后取消观察</span><br><span class="line">unwatch()</span><br></pre></td></tr></table></figure><h2 id="创建-User-Watcher"><a href="#创建-User-Watcher" class="headerlink" title="创建 User Watcher"></a>创建 User Watcher</h2><p>new Watcher 的时候执行 Watcher 的构造函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span> (</span><br><span class="line">   vm: Component,</span><br><span class="line">   expOrFn: string | Function,</span><br><span class="line">   cb: Function,</span><br><span class="line">   options?: ?Object,</span><br><span class="line">   isRenderWatcher?: boolean</span><br><span class="line"> ) &#123;</span><br><span class="line">   <span class="keyword">this</span>.vm = vm</span><br><span class="line">   <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">     vm._watcher = <span class="keyword">this</span></span><br><span class="line">   &#125;</span><br><span class="line">   vm._watchers.push(<span class="keyword">this</span>)</span><br><span class="line">   <span class="comment">// options</span></span><br><span class="line">   <span class="keyword">if</span> (options) &#123;</span><br><span class="line">     <span class="keyword">this</span>.deep = !!options.deep</span><br><span class="line">     <span class="keyword">this</span>.user = !!options.user</span><br><span class="line">     <span class="keyword">this</span>.lazy = !!options.lazy</span><br><span class="line">     <span class="keyword">this</span>.sync = !!options.sync</span><br><span class="line">     <span class="keyword">this</span>.before = options.before</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">this</span>.deep = <span class="keyword">this</span>.user = <span class="keyword">this</span>.lazy = <span class="keyword">this</span>.sync = <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">this</span>.cb = cb</span><br><span class="line">   <span class="keyword">this</span>.id = ++uid <span class="comment">// uid for batching</span></span><br><span class="line">   <span class="keyword">this</span>.active = <span class="literal">true</span></span><br><span class="line">   <span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy <span class="comment">// for lazy watchers</span></span><br><span class="line">   <span class="keyword">this</span>.deps = []</span><br><span class="line">   <span class="keyword">this</span>.newDeps = []</span><br><span class="line">   <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">   <span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">   <span class="keyword">this</span>.expression = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line">     ? expOrFn.toString()</span><br><span class="line">     : <span class="string">''</span></span><br><span class="line">   <span class="comment">// parse expression for getter</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">     <span class="keyword">this</span>.getter = expOrFn</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">     <span class="keyword">if</span> (!<span class="keyword">this</span>.getter) &#123;</span><br><span class="line">       <span class="keyword">this</span>.getter = noop</span><br><span class="line">       process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">         <span class="string">`Failed watching path: "<span class="subst">$&#123;expOrFn&#125;</span>" `</span> +</span><br><span class="line">         <span class="string">'Watcher only accepts simple dot-delimited paths. '</span> +</span><br><span class="line">         <span class="string">'For full control, use a function instead.'</span>,</span><br><span class="line">         vm</span><br><span class="line">       )</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy</span><br><span class="line">     ? <span class="literal">undefined</span></span><br><span class="line">     : <span class="keyword">this</span>.get()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里 this.getter 为 parsePath 函数执行后返回的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parsePath</span> (<span class="params">path: string</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bailRE.test(path)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> segments = path.split(<span class="string">'.'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segments.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!obj) <span class="keyword">return</span></span><br><span class="line">      obj = obj[segments[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的函数主要是用于对当前的 vm 上的数据属性进行获取, 从而触发对应监听数据响应式对象的 getter.</p><p>由于当前的 watcher 不是 computed watcher, 所以不需要延后计算, 于是 user watcher 主要调用 this.get 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> () &#123;</span><br><span class="line">  <span class="keyword">debugger</span></span><br><span class="line">  <span class="comment">// 把当前的渲染watcher赋值给Dep.target</span></span><br><span class="line">  pushTarget(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">let</span> value</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行在mountComponet中传入的updateComponent</span></span><br><span class="line">    value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">      handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">    <span class="comment">// dependencies for deep watching</span></span><br><span class="line">    <span class="keyword">debugger</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">      traverse(value)</span><br><span class="line">    &#125;</span><br><span class="line">    popTarget()</span><br><span class="line">    <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把当前的 user watcher 赋值给 Dep.target, 然后执行 this.getter, 触发定义监听的响应式数据依赖收集当前的 user watcher, 当 deep 为 true, 则会调用 traverse 对响应式数据进行深度遍历并触发对应的响应式数据的 getter, 从而达到深度监听子属性的功能. </p><h2 id="数据变化触发响应"><a href="#数据变化触发响应" class="headerlink" title="数据变化触发响应"></a>数据变化触发响应</h2><p>当监听的响应式数据发生变化时, 对应的 setter 方法执行, 接着触发 被收集的 user watcher 的 update 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">    <span class="keyword">this</span>.run()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>update 方法这里执行 queueWatcher 方法在下一个 tick 后对视图进行更新, 而在对视图进行更新过程中, flushSchedulerQueue 会触发 user watcher 的 run 方法, </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">run () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">this</span>.get()</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      value !== <span class="keyword">this</span>.value ||</span><br><span class="line">      <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">      <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">      <span class="comment">// have mutated.</span></span><br><span class="line">      isObject(value) ||</span><br><span class="line">      <span class="keyword">this</span>.deep</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// set new value</span></span><br><span class="line">      <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">      <span class="keyword">this</span>.value = value</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          handleError(e, <span class="keyword">this</span>.vm, <span class="string">`callback for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后执行了用户定义 watch 属性传入的 handler 函数, 这里为: this.cb.call(this.vm, value, oldValue).</p><p>到这里已经大概了解了整个 user watcher, 从定义, 初始化, 数据监听依赖收集, 更新触发响应函数执行的过程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vue-logo.png&quot; alt=&quot;Vue&quot;&gt;&lt;/p&gt;
&lt;p&gt;对于用户定义的 Watche 属性官方描述如下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码浅析之Computed初始化</title>
    <link href="http://yoursite.com/2019/07/03/Vue%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90%E4%B9%8BComputed%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2019/07/03/Vue源码浅析之Computed初始化/</id>
    <published>2019-07-03T15:48:36.000Z</published>
    <updated>2021-07-20T03:24:10.676Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vue-logo.png" alt="Vue"></p><h2 id="什么是计算属性"><a href="#什么是计算属性" class="headerlink" title="什么是计算属性"></a>什么是计算属性</h2><p>官方文档描述如下:</p><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  &#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 message 的翻转字符串。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。</p><p>所以，对于任何复杂逻辑，你都应当使用计算属性。</p><p>个人理解如下:</p><p>computed 主要的用途是把一个或多个变量进行计算处理, 得到计算后的结果, 其能够监听当前所依赖的变量的变更, 并重新计算变更的结果, 进而触发视图进行渲染更新。</p><p>这次就来探索一下 computed 的原理实现。</p><h2 id="Computed-初始化-Get-过程"><a href="#Computed-初始化-Get-过程" class="headerlink" title="Computed 初始化 Get 过程"></a>Computed 初始化 Get 过程</h2><p>在实例化 Vue 的过程中, initState 函数实现如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options</span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 响应式处理</span></span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里判断我们的 opts 可选参数是否传入 computed 属性, 若有则执行 initComputed 进行初始化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> computedWatcherOptions = &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">vm: Component, computed: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> watchers = vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// computed properties are just getters during SSR</span></span><br><span class="line">  <span class="keyword">const</span> isSSR = isServerRendering()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">const</span> userDef = computed[key]</span><br><span class="line">    <span class="keyword">const</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">'function'</span> ? userDef : userDef.get</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; getter == <span class="literal">null</span>) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Getter is missing for computed property "<span class="subst">$&#123;key&#125;</span>".`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">      <span class="comment">// create internal watcher for the computed property.</span></span><br><span class="line">      watchers[key] = <span class="keyword">new</span> Watcher(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// component-defined computed properties are already defined on the</span></span><br><span class="line">    <span class="comment">// component prototype. We only need to define computed properties defined</span></span><br><span class="line">    <span class="comment">// at instantiation here.</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      defineComputed(vm, key, userDef)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> vm.$data) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property "<span class="subst">$&#123;key&#125;</span>" is already defined in data.`</span>, vm)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.$options.props &amp;&amp; key <span class="keyword">in</span> vm.$options.props) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property "<span class="subst">$&#123;key&#125;</span>" is already defined as a prop.`</span>, vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initComputed 先定义了一个 watchers 用于保存当前 computed 对象各个计算属性所以对应的 computed watcher。这个 computed watcher 用途我们后续会介绍。把用户定义的 computed 属性对应的 getter 函数进行获取。</p><p>接着, 就根据计算属性的 key 值实例化一个相对应的 computed watcher, 这个 watcher 为啥叫 computed watcher, 因为我们看到 Watcher 的构造函数传参有 computedWatcherOptions = { lazy: true }。表示这是一个 computed watcher, 用于计算属性监听所使用, 和之前说过的渲染 watcher 有所区别。computed watcher 的构造函数还会传入当前的 vm 实例, computed 属性中对应的 getter。</p><p>这时候我们看下 new Watcher 的实现。</p><h3 id="实例化-computed-watcher"><a href="#实例化-computed-watcher" class="headerlink" title="实例化 computed watcher"></a>实例化 computed watcher</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span> (</span><br><span class="line">  vm: Component,</span><br><span class="line">  expOrFn: string | Function,</span><br><span class="line">  cb: Function,</span><br><span class="line">  options?: ?Object,</span><br><span class="line">  isRenderWatcher?: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">this</span>.vm = vm</span><br><span class="line">  <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">    vm._watcher = <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">  vm._watchers.push(<span class="keyword">this</span>)</span><br><span class="line">  <span class="comment">// options</span></span><br><span class="line">  <span class="keyword">if</span> (options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.deep = !!options.deep</span><br><span class="line">    <span class="keyword">this</span>.user = !!options.user</span><br><span class="line">    <span class="comment">// lazy 为 true</span></span><br><span class="line">    <span class="keyword">this</span>.lazy = !!options.lazy</span><br><span class="line">    <span class="keyword">this</span>.sync = !!options.sync</span><br><span class="line">    <span class="keyword">this</span>.before = options.before</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.deep = <span class="keyword">this</span>.user = <span class="keyword">this</span>.lazy = <span class="keyword">this</span>.sync = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.cb = cb</span><br><span class="line">  <span class="keyword">this</span>.id = ++uid <span class="comment">// uid for batching</span></span><br><span class="line">  <span class="keyword">this</span>.active = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy <span class="comment">// for lazy watchers</span></span><br><span class="line">  <span class="keyword">this</span>.deps = []</span><br><span class="line">  <span class="keyword">this</span>.newDeps = []</span><br><span class="line">  <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  <span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  <span class="keyword">this</span>.expression = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line">    ? expOrFn.toString()</span><br><span class="line">    : <span class="string">''</span></span><br><span class="line">  <span class="comment">// parse expression for getter</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.getter = expOrFn</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.getter) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = noop</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">`Failed watching path: "<span class="subst">$&#123;expOrFn&#125;</span>" `</span> +</span><br><span class="line">        <span class="string">'Watcher only accepts simple dot-delimited paths. '</span> +</span><br><span class="line">        <span class="string">'For full control, use a function instead.'</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy</span><br><span class="line">    ? <span class="literal">undefined</span></span><br><span class="line">    : <span class="keyword">this</span>.get()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 this.lazy 为 true, 然后会把用户定义的 getter 传入的并保存在当前 computed watcher 的 this.getter中。</p><h3 id="defineComputed-实现"><a href="#defineComputed-实现" class="headerlink" title="defineComputed 实现"></a>defineComputed 实现</h3><p>接下来我们需要关注一下英文注释：</p><p>component-defined computed properties are already defined on the<br>component prototype. We only need to define computed properties defined<br>at instantiation here.</p><p>这句话其实就是介绍, 对于子组件来说, 其声明的 computed 属性已经被定义在当前组件的原型中, 这时候 key in vm 其实会为 true。</p><p>为什么已经定义在子组件中呢?</p><p>我们可以了解到, 在对子组件在初始化的过程中, 会通过 Vue.extend 来获取组件的构造器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承组件定义</span></span><br><span class="line"><span class="keyword">const</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 执行Vue.prototype._init方法</span></span><br><span class="line">  <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承父组件Vue的原型</span></span><br><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype)</span><br><span class="line"><span class="comment">// 拦截重置构造函数</span></span><br><span class="line">Sub.prototype.constructor = Sub</span><br><span class="line"></span><br><span class="line">...省略</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Sub.options.props) &#123;</span><br><span class="line">  initProps(Sub)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Sub.options.computed) &#123;</span><br><span class="line">  initComputed(Sub)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue.extend 的方法其实在进行 initState 的 initComputed 调用前, 已经在获取子组件的构造器的时候就调用了 initComputed 对 computed 进行挂载初始化了。</p><p>defineComputed 的实现如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineComputed</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: any, <span class="regexp">//</span> Sub原型</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  userDef: Object | Function <span class="regexp">//</span> computed getter<span class="regexp">/setter</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">  const shouldCache = !isServerRendering()</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">  if (typeof userDef === 'function') &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">    sharedPropertyDefinition.get = shouldCache</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">      ? createComputedGetter(key)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">      : createGetterInvoker(userDef)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">    sharedPropertyDefinition.set = noop</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">  &#125; else &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">    sharedPropertyDefinition.get = userDef.get</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">      ? shouldCache &amp;&amp; userDef.cache !== false</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">        ? createComputedGetter(key)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">        : createGetterInvoker(userDef.get)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">      : noop</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">    sharedPropertyDefinition.set = userDef.set || noop</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">  &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">  if (process.env.NODE_ENV !== 'production' &amp;&amp;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">      sharedPropertyDefinition.set === noop) &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">    sharedPropertyDefinition.set = function () &#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">      warn(</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">        `Computed property "$&#123;key&#125;" was assigned to but it has no setter.`,</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">        this</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">      )</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">    &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">  &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">  Object.defineProperty(target, key, sharedPropertyDefinition)</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="regexp">&#125;</span></span></span></span><br></pre></td></tr></table></figure><p>defineComputed 其实通过 Object.defineProperty 为当前的 Sub 原型定义对应计算属性的 getter/setter, 在原型上定义主要是为了给多个组件能够共享调用 createComputedGetter 这个 getter 的优化点。</p><h3 id="createComputedGetter-实现"><a href="#createComputedGetter-实现" class="headerlink" title="createComputedGetter 实现"></a>createComputedGetter 实现</h3><p>接下来主要看下 createComputedGetter 的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">this</span>._computedWatchers &amp;&amp; <span class="keyword">this</span>._computedWatchers[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">        watcher.evaluate()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        watcher.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> watcher.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">evaluate () &#123;</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">  <span class="keyword">this</span>.dirty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createComputedGetter 返回一个函数, 这个函数 computedGetter 就是每个 computed 属性所对应的 getter 函数, 当 computed 的属性被访问时, 比如在渲染过程中属性被访问, 会触发 computedGetter 的执行, 该函数其实就是触发当前 computed watcher 的 evaluate 或者 depend 方法执行, 一开始 watcher.dirty 为 true, 原因是 dirty 的初始值其实就是我们传入的 computedWatcherOptions = { lazy: true } 的 lazy。于是执行 watcher.evaluate() 这时候会调用 this.get() 进行求值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> () &#123;</span><br><span class="line">  <span class="comment">// 把当前的watcher, 渲染watcher 或者 computed watcher 赋值给Dep.target</span></span><br><span class="line">  pushTarget(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">let</span> value</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行在mountComponet中传入的updateComponent</span></span><br><span class="line">    value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">      handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">    <span class="comment">// dependencies for deep watching</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">      traverse(value)</span><br><span class="line">    &#125;</span><br><span class="line">    popTarget()</span><br><span class="line">    <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们之前已经了解，pushTarget(this) 其实就是把当前的 computed watcher 赋值给 Dep.target, 接着执行 this.getter 计算 computed 属性对应的数值。</p><p>这里需要特别注意一点, this.getter 为用户给 computed 属性定义的 getter 方法, 此方法执行会触发这个方法所依赖的响应式数据的 getter 的执行。</p><p>这时候需要特别关注，当前的 Dep.target 为此时 computed 属性对应的 computed watcher, 而触发响应式数据的 getter 的执行则会使得响应式数据对象对应的 dep 收集 Dep.target, 也就是此时的 computed watcher。当前的 computed watcher 会被 push 到响应式对象的 dep.subs 的数组中, 这里其实就是当前的 computed watcher 订阅了所依赖的响应式数据的变化。</p><p>最后执行完成后调用 popTarget 把原始的 watcher, 比如渲染 watcher 恢复重新赋值给 Dep.target。</p><p>this.get() 执行完成后则把 this.dirty 置为 false。</p><p>回到 computedGetter, 如果处于渲染过程中, 也就是 Dep.target 不为空, 则继续执行了 watcher.depend </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">depend () &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">this</span>.deps[i].depend()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前的 computed watcher 已经订阅了所依赖的响应式数据的变化, 于是 computed watcher 的 deps 为所有依赖的响应式数据对应的 Dep。于是执行 dep.depend, 把当前的 Dep.target 也就是当前的渲染 watcher, push 到每个响应式数据对象所对应的 dep.subs 中。当前的渲染 watcher 订阅了 computed watcher 所依赖的数据的变化, 用于依赖数据更新触发视图 update 渲染。完成后, 然后返回通过 evaluate 计算得到的值。</p><p>这里整个 computed 的 get 求值就已经完成了。</p><h2 id="Computed-变更-Set-过程"><a href="#Computed-变更-Set-过程" class="headerlink" title="Computed 变更 Set 过程"></a>Computed 变更 Set 过程</h2><p>当 computed 属性所依赖的响应式数据发生变更后, 则响应式数据会触发其对应的 setter 执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">  <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">  <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">  <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">    customSetter()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">  <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">    setter.call(obj, newVal)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    val = newVal</span><br><span class="line">  &#125;</span><br><span class="line">  childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">  dep.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set 的执行我们之前有了解过, 这里主要看两个点</p><ul><li>newVal === value || (newVal !== newVal &amp;&amp; value !== value)</li><li>dep.notify()</li></ul><p>第一个是 set 的触发会对比当前更新的值是否发生变更, 如果没有变更则直接 return 不往下执行触发视图更新。</p><p>第二个则是执行了当前响应式数据对象对应的 dep 的 notify 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">notify () &#123;</span><br><span class="line">  <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">  <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">    <span class="comment">// subs aren't sorted in scheduler if not running async</span></span><br><span class="line">    <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">    <span class="comment">// order</span></span><br><span class="line">    subs.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">    subs[i].update()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在 get 过程中, 计算属性对应的 computed watcher 订阅了响应式数据的 dep, 这时候会通知 computed watcher 进行 update, 对应的渲染 watcher 也订阅了响应式数据的 dep, 也会执行 update。</p><p>computed watcher 的 update 会先执行, 然后执行渲染 watcher 的 update</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">    <span class="keyword">this</span>.run()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>computed watcher 执行 update 把其对应的 dirty 属性置为 true, 接着执行渲染 watcher 的update, 渲染 watcher 的 update 执行了 queueWatcher 让视图在下一个 tick 进行更新。</p><p>于是视图进行 flushSchedulerQueue 更新, 渲染 watcher 的更新会触发 computed 属性的 getter, 所以就再次执行 computedGetter 的执行, computed watcher 的 evaluate 和 depend 再次执行, 重新依赖收集所依赖的响应式数据, 接着返回数据更新后的新的 computed 值, 接着视图触发渲染更新。</p><p>这里已经完成了整个 computed 属性的初始化的解析以及当 computed 属性所依赖的数据发生变更后的重新计算依赖和数值的过程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vue-logo.png&quot; alt=&quot;Vue&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是计算属性&quot;&gt;&lt;a href=&quot;#什么是计算属性&quot; class=&quot;headerlink&quot; title=&quot;什么是计算属性&quot;&gt;&lt;/a&gt;什么是计算属性&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码浅析之nextTick</title>
    <link href="http://yoursite.com/2019/06/26/Vue%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90%E4%B9%8BnextTick/"/>
    <id>http://yoursite.com/2019/06/26/Vue源码浅析之nextTick/</id>
    <published>2019-06-26T14:19:46.000Z</published>
    <updated>2021-07-20T03:24:10.676Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vue-logo.png" alt="Vue"></p><h2 id="nextTicke-的作用"><a href="#nextTicke-的作用" class="headerlink" title="nextTicke 的作用"></a>nextTicke 的作用</h2><p>官方文档描述如下:</p><blockquote><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p></blockquote><p>从这个描述我们可以知道，nextTick 方法用于在视图渲染更新结束后进行回调方法执行, 目的是保证我们在回调方法中操作的 DOM 是已经完成视图更新渲染。</p><h2 id="回顾响应式更新派发"><a href="#回顾响应式更新派发" class="headerlink" title="回顾响应式更新派发"></a>回顾响应式更新派发</h2><p>我们已经知道当数据发送变更, 会触发响应式数据对象的 setter 方法, 接着订阅该数据更新的渲染 watcher 执行 queueWatcher, queueWatcher 的实现就是使用 nextTick(flushSchedulerQueue) 来实现视图的异步更新。</p><h2 id="nextTick-的实现"><a href="#nextTick-的实现" class="headerlink" title="nextTick 的实现"></a>nextTick 的实现</h2><p>nextTick 的源码定义在 core/util/next-tick.js 中</p><p>我们先看一下这个模块定义的全局变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; noop &#125; <span class="keyword">from</span> <span class="string">'shared/util'</span></span><br><span class="line"><span class="keyword">import</span> &#123; handleError &#125; <span class="keyword">from</span> <span class="string">'./error'</span></span><br><span class="line"><span class="keyword">import</span> &#123; isIE, isIOS, isNative &#125; <span class="keyword">from</span> <span class="string">'./env'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否使用微任务标识</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> isUsingMicroTask = <span class="literal">false</span></span><br><span class="line"><span class="comment">// 收集回调函数</span></span><br><span class="line"><span class="keyword">const</span> callbacks = []</span><br><span class="line"><span class="comment">// Promise 的判断标识</span></span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这里需要关注一下 callbacks 这个数组, 它的作用是为了收集每次调用 nextTick 方法对应的回调函数, 保证每个回调函数有序执行。 </p><p>我们先看下 nextTick 的定义<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb?: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">'nextTick'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    timerFunc()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>nextTick 实现很简单，如果是通过回调函数的形式来调用, 则把传入的回调函数 push 到 callbacks 这个数组中, 被 push 的回调函数会被封装为一个匿名函数, 这个匿名对每个回调函数进行 try/catch 的异常捕获, 目的是为了保证当某个回调函数发生异常时, 不影响 js 的进一步执行。如果是使用 Promise 的方式进行 nextTick 进行调用, 则会 new 一个 Promsie 对象并把 resolve 赋值给 _resolve 以便链式调用。</p><p>一开始 pending 为 false, 所以会执行 timerFunc。</p><p>这里我们看下 timerFunc 是怎么实现的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timerFunc</span><br><span class="line"></span><br><span class="line"><span class="comment">// The nextTick behavior leverages the microtask queue, which can be accessed</span></span><br><span class="line"><span class="comment">// via either native Promise.then or MutationObserver.</span></span><br><span class="line"><span class="comment">// MutationObserver has wider support, however it is seriously bugged in</span></span><br><span class="line"><span class="comment">// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It</span></span><br><span class="line"><span class="comment">// completely stops working after triggering a few times... so, if native</span></span><br><span class="line"><span class="comment">// Promise is available, we will use it:</span></span><br><span class="line"><span class="comment">/* istanbul ignore next, $flow-disable-line */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    <span class="comment">// In problematic UIWebViews, Promise.then doesn't completely break, but</span></span><br><span class="line">    <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">    <span class="comment">// microtask queue but the queue isn't being flushed, until the browser</span></span><br><span class="line">    <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">    <span class="comment">// "force" the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) setTimeout(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">'undefined'</span> &amp;&amp; (</span><br><span class="line">  isNative(MutationObserver) ||</span><br><span class="line">  <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">  MutationObserver.toString() === <span class="string">'[object MutationObserverConstructor]'</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="comment">// Use MutationObserver where native Promise is not available,</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// (#6466 MutationObserver is unreliable in IE11)</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  <span class="comment">// Fallback to setImmediate.</span></span><br><span class="line">  <span class="comment">// Techinically it leverages the (macro) task queue,</span></span><br><span class="line">  <span class="comment">// but it is still a better choice than setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>timerFunc 会根据不同浏览器的原生异步任务支持情况来选择对应的异步任务创建类型, 这里简单列举这里的异步任务类型:</p><ul><li>Promise 微任务</li><li>MutationObserver 微任务</li><li>setImmediate 宏任务</li><li>setTimeout 宏任务</li></ul><p>timerFunc 本质就是创建一个异步任务来执行 flushCallbacks 这个函数。目的是为了让传入 nextTick 的回调函数是异步执行的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">  callbacks.length = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flushCallbacks 其实就是遍历 callbacks 数组里面的回调函数并依次执行。</p><p>对于用户调用 Vue.nextTick 暴露的 api 接口传入对应的回调函数, 其执行总会是在视图完成渲染更新后才进行, 因为当数据发生变更, 触发渲染 watcher 执行 queueWatcher, 这时候 vue 内部调用 nextTick 先保证 flushSchedulerQueue 这个方法是先被 push 到 callbacks 这个回调数组。</p><p>举个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p ref=<span class="string">"dom"</span>&gt;&#123;&#123;msg&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button @click="handleChange"&gt;change&lt;/</span>button&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">'vue'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleChange () &#123;</span><br><span class="line">      <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.refs.dom.msg, <span class="string">'pre'</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.msg = <span class="string">'vue-nextTick'</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.refs.dom.msg, <span class="string">'common'</span>);</span><br><span class="line">      <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.refs.dom.msg, <span class="string">'after'</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这时候的输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vue common</span><br><span class="line">vue pre</span><br><span class="line">vue-nextTick after</span><br></pre></td></tr></table></figure></p><p>这里我们简单来看下对应的函数执行顺序, 我们把第一个 nextTick 的回调函数取名 preTick, 第二个叫 afterTick</p><p>同步代码执行: </p><p>callbacks.push(preTick)<br>callbacks.push(flushSchedulerQueue) // 修改 msg 的值所触发<br>console.log(this.refs.dom.msg, ‘common’) // 输出 vue common<br>callbacks.push(afterTick)</p><p>同步代码执行完成后, 执行 flushCallbacks 遍历执行回调函数:</p><p>preTick // 输出 vue pre<br>flushSchedulerQueue // 视图进行数据更新渲染, this.refs.dom.msg 为 vue-nextTick<br>afterTick // 输出 vue-nextTick after</p><p>到这里已经完成对 nextTick 的分析，其实 nextTick 的实现并不复杂, 如果已经深入了解浏览器 js 的执行机制可能会更容易理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vue-logo.png&quot; alt=&quot;Vue&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;nextTicke-的作用&quot;&gt;&lt;a href=&quot;#nextTicke-的作用&quot; class=&quot;headerlink&quot; title=&quot;nextTicke 的作用&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码浅析之更新派发</title>
    <link href="http://yoursite.com/2019/06/20/Vue%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90%E4%B9%8B%E6%9B%B4%E6%96%B0%E6%B4%BE%E5%8F%91/"/>
    <id>http://yoursite.com/2019/06/20/Vue源码浅析之更新派发/</id>
    <published>2019-06-20T14:39:45.000Z</published>
    <updated>2021-07-20T03:24:10.676Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vue-logo.png" alt="Vue"></p><p>getter 就是为了追踪依赖, 对依赖进行收集。而 setter 则是通知变化, 让视图进行更新。</p><p>之前已经探索了 vue 在 触发响应式对象的 getter 时候, 通过把组件对应的渲染 watcher 进行依赖收集, 这些 watcher 最终会被收集到 dep.subs 的数组中。</p><h2 id="回顾-defineReactive-源码"><a href="#回顾-defineReactive-源码" class="headerlink" title="回顾 defineReactive 源码"></a>回顾 defineReactive 源码</h2><p>那当数据发生变更，这时候会触发响应式对象的 setter, 重新看下 defineReactive 的源码实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  </span><br><span class="line">  ...省略</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123; ...省略 &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, 响应式对象的 setter 其实先获取当前的数据变更, 判断数据是否发生变更, 然后会对变更的数据进行 observe 响应式对象初始化, 当然前提是 newVal 是一个非 Vnode 类型的对象。接着这里调用当前响应式对象初始化过程中已经实例化的 dep 的 notify 方法。</p><p>而这时候 dep 的 subs 数组其实已经把当前订阅这个数据对象变更的渲染 watcher 收集起来了。</p><p>那我们看下 notify 的实现</p><h2 id="更新派发过程"><a href="#更新派发过程" class="headerlink" title="更新派发过程"></a>更新派发过程</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">notify () &#123;</span><br><span class="line">  <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">  <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">    <span class="comment">// subs aren't sorted in scheduler if not running async</span></span><br><span class="line">    <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">    <span class="comment">// order</span></span><br><span class="line">    subs.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">    subs[i].update()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实就是对 subs 的订阅者 watcher 进行遍历, 并调用 watcher 的 update 方法。 通俗一点来说, 就是通知 subs 里面的 watcher 去执行 update 方法, 从而进行视图更新。</p><p>我们看下 Watcher 实现的 update 方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Subscriber interface.</span></span><br><span class="line"><span class="comment">  * Will be called when a dependency changes.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">update () &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">    <span class="keyword">this</span>.run()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run 方法下面会详细分析。</p><p>这里比较关键的是先关注 queueWatcher 这个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queue: <span class="built_in">Array</span>&lt;Watcher&gt; = []</span><br><span class="line"><span class="keyword">const</span> activatedChildren: <span class="built_in">Array</span>&lt;Component&gt; = []</span><br><span class="line"><span class="keyword">let</span> has: &#123; [key: number]: ?<span class="literal">true</span> &#125; = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> circular: &#123; [key: number]: number &#125; = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> waiting = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> flushing = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Push a watcher into the watcher queue.</span></span><br><span class="line"><span class="comment"> * Jobs with duplicate IDs will be skipped unless it's</span></span><br><span class="line"><span class="comment"> * pushed when the queue is being flushed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span> (<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.id</span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">      <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// queue the flush</span></span><br><span class="line">    <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">      waiting = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">        flushSchedulerQueue()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      nextTick(flushSchedulerQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过全局的 has 对象来保证每次同一个 Watcher 只能被添加一次到 queue 这个队列。全局的 index 用于记录当前队列遍历的下标。一开始 flushing 和 waiting 都为 false, 所以执行 queue.push(watcher), 接着通过 nextTick 来异步执行 flushSchedulerQueue。至于 nextTick 怎么实现以后再单独探索, 反正就先认为是用来实现异步更新的机制。</p><p>当同步的代码执行完成了, 就会执行 nextTicke 的回调方法 flushSchedulerQueue</p><h2 id="flushSchedulerQueue-分析"><a href="#flushSchedulerQueue-分析" class="headerlink" title="flushSchedulerQueue 分析"></a>flushSchedulerQueue 分析</h2><p>这里我们重点分析一下这个 flushSchedulerQueue 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flush both queues and run the watchers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  currentFlushTimestamp = getNow()</span><br><span class="line">  flushing = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">let</span> watcher, id</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sort queue before flush.</span></span><br><span class="line">  <span class="comment">// This ensures that:</span></span><br><span class="line">  <span class="comment">// 1. Components are updated from parent to child. (because parent is always</span></span><br><span class="line">  <span class="comment">//    created before the child)</span></span><br><span class="line">  <span class="comment">// 2. A component's user watchers are run before its render watcher (because</span></span><br><span class="line">  <span class="comment">//    user watchers are created before the render watcher)</span></span><br><span class="line">  <span class="comment">// 3. If a component is destroyed during a parent component's watcher run,</span></span><br><span class="line">  <span class="comment">//    its watchers can be skipped.</span></span><br><span class="line">  queue.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do not cache length because more watchers might be pushed</span></span><br><span class="line">  <span class="comment">// as we run existing watchers</span></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class="line">    watcher = queue[index]</span><br><span class="line">    <span class="keyword">if</span> (watcher.before) &#123;</span><br><span class="line">      watcher.before()</span><br><span class="line">    &#125;</span><br><span class="line">    id = watcher.id</span><br><span class="line">    has[id] = <span class="literal">null</span></span><br><span class="line">    watcher.run()</span><br><span class="line">    <span class="comment">// in dev build, check and stop circular updates.</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; has[id] != <span class="literal">null</span>) &#123;</span><br><span class="line">      circular[id] = (circular[id] || <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> (circular[id] &gt; MAX_UPDATE_COUNT) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'You may have an infinite update loop '</span> + (</span><br><span class="line">            watcher.user</span><br><span class="line">              ? <span class="string">`in watcher with expression "<span class="subst">$&#123;watcher.expression&#125;</span>"`</span></span><br><span class="line">              : <span class="string">`in a component render function.`</span></span><br><span class="line">          ),</span><br><span class="line">          watcher.vm</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keep copies of post queues before resetting state</span></span><br><span class="line">  <span class="keyword">const</span> activatedQueue = activatedChildren.slice()</span><br><span class="line">  <span class="keyword">const</span> updatedQueue = queue.slice()</span><br><span class="line"></span><br><span class="line">  resetSchedulerState()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// call component updated and activated hooks</span></span><br><span class="line">  callActivatedHooks(activatedQueue)</span><br><span class="line">  callUpdatedHooks(updatedQueue)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// devtool hook</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (devtools &amp;&amp; config.devtools) &#123;</span><br><span class="line">    devtools.emit(<span class="string">'flush'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flashing-的标记为被置为-true"><a href="#flashing-的标记为被置为-true" class="headerlink" title="flashing 的标记为被置为 true"></a>flashing 的标记为被置为 true</h3><h3 id="对全局保存-watcher-的这个-queue-队列进行排序"><a href="#对全局保存-watcher-的这个-queue-队列进行排序" class="headerlink" title="对全局保存 watcher 的这个 queue 队列进行排序"></a>对全局保存 watcher 的这个 queue 队列进行排序</h3><p>排序的注释翻译如下:</p><ul><li>组件的创建从父到子进行, 所以组件的 watcher 也是先进行父级的创建, 再到子级的创建, 对应 watcher 的执行也需要保证从父到子</li><li>用户自定义的 watcher 优先于组件渲染 watcher 的创建</li><li>如果一个组件在父组件的 watcher 执行期间被 destroyed, 则这个子级对应的 watcher 会被跳过执行</li></ul><h3 id="执行在-new-Watcher-时候传入的-before-函数进行-hook-的执行"><a href="#执行在-new-Watcher-时候传入的-before-函数进行-hook-的执行" class="headerlink" title="执行在 new Watcher 时候传入的 before 函数进行 hook 的执行"></a>执行在 new Watcher 时候传入的 before 函数进行 hook 的执行</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">  before () &#123;</span><br><span class="line">    <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">      callHook(vm, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br></pre></td></tr></table></figure><h3 id="watcher-run-进行视图更新"><a href="#watcher-run-进行视图更新" class="headerlink" title="watcher.run 进行视图更新"></a>watcher.run 进行视图更新</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Scheduler job interface.</span></span><br><span class="line"><span class="comment">  * Will be called by the scheduler.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">run () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">this</span>.get()</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      value !== <span class="keyword">this</span>.value ||</span><br><span class="line">      <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">      <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">      <span class="comment">// have mutated.</span></span><br><span class="line">      isObject(value) ||</span><br><span class="line">      <span class="keyword">this</span>.deep</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// set new value</span></span><br><span class="line">      <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">      <span class="keyword">this</span>.value = value</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          handleError(e, <span class="keyword">this</span>.vm, <span class="string">`callback for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Evaluate the getter, and re-collect dependencies.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">get</span> () &#123;</span><br><span class="line">  <span class="comment">// 把当前的渲染watcher赋值给Dep.target</span></span><br><span class="line">  pushTarget(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">let</span> value</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行在mountComponet中传入的updateComponent</span></span><br><span class="line">    value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">      handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">    <span class="comment">// dependencies for deep watching</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">      traverse(value)</span><br><span class="line">    &#125;</span><br><span class="line">    popTarget()</span><br><span class="line">    <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run 方法其实调用 this.get, 而 get 这里有个 pushTarget 会导致 Dep.target 变更为当前的 watcher, 然后执行 this.getter =&gt; updateComponet =&gt; _update =&gt; render 触发组件重新渲染。</p><h3 id="用户自定义-watcher"><a href="#用户自定义-watcher" class="headerlink" title="用户自定义 watcher"></a>用户自定义 watcher</h3><p>run 方法执行同时会判断如果当前的 watcher 是属于用户自定义的 watcher, 则这时候会执行用户定义的回调方法, 而这个用户定义的回调方法很可能会再次进行数据更新修改, 从而再次触发 queueWatcher 的执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span> (<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.id</span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">      <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// queue the flush</span></span><br><span class="line">    <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">      waiting = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">        flushSchedulerQueue()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      nextTick(flushSchedulerQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这时候由于 flashing 为true, 所以 queueWatcher 会进入 else 的逻辑, 然后从后往前找，找到第一个待插入 watcher 的 id 比当前队列中 watcher 的 id 大的位置。把 watcher 按照 id的插入到队列中，因此 queue 的长度发送了变化。</p><h3 id="恢复状态"><a href="#恢复状态" class="headerlink" title="恢复状态"></a>恢复状态</h3><p>resetSchedulerState 方法是用于把一些逻辑流程执行的变量进行重置为初始值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetSchedulerState</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  index = queue.length = activatedChildren.length = <span class="number">0</span></span><br><span class="line">  has = &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    circular = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  waiting = flushing = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h2><p>组件的数据更新触发视图更新，通过 getter 把订阅当前响应式对象数据的渲染 watcher 进行收集, 并保存到 dep 的 subs 中, 当数据进行更新触发 setter 的时候先是遍历 subs 执行每个 watcher 的 update 方法, 把当前的所有 watcher 保存到一个队列的结构中,  在同步的代码执行完成后, 通过 nextTick 来异步执行 flushSchedulerQueue 进行队列的遍历, 然后执行对应的 watcher 的 run 方法进行组件 patch 更新以及对应的响应对象的依赖重新收集。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vue-logo.png&quot; alt=&quot;Vue&quot;&gt;&lt;/p&gt;
&lt;p&gt;getter 就是为了追踪依赖, 对依赖进行收集。而 setter 则是通知变化, 让视图进行更新。&lt;/p&gt;
&lt;p&gt;之前已经探索了 vue 在 触发响应式对象的 getter
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码浅析之依赖收集</title>
    <link href="http://yoursite.com/2019/06/18/Vue%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86/"/>
    <id>http://yoursite.com/2019/06/18/Vue源码浅析之依赖收集/</id>
    <published>2019-06-18T15:52:27.000Z</published>
    <updated>2021-07-20T03:24:10.676Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vue-logo.png" alt="Vue"></p><h2 id="响应式对象Getter-Setter"><a href="#响应式对象Getter-Setter" class="headerlink" title="响应式对象Getter/Setter"></a>响应式对象Getter/Setter</h2><p>前一篇文章讲了响应式对象的初始化，其中我们了解到 defineReactive 最终就是通过  Object.defineProperty 为数据对象定义 getter/setter, 我们看下官方文档对 getter/setter 的解释:</p><blockquote><p>getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化</p></blockquote><p>我们可以知道 getter 其实就是为了追踪依赖, 对依赖进行收集。而 setter 则是通知变化, 让视图进行更新.</p><p>这次我们先了解一下 getter 如何进行依赖收集。</p><h2 id="回顾-defineReactive-源码"><a href="#回顾-defineReactive-源码" class="headerlink" title="回顾 defineReactive 源码"></a>回顾 defineReactive 源码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 实例化一个 Dep 对象</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="comment">// 获取对象的属性描述符</span></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        <span class="comment">// 收集当前的渲染watcher，作为订阅者，方便set的时候进行触发更新</span></span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      ...省略</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>defineReactive 在函数开始执行时实例化了一个 Dep 对象, 然后在 getter 函数中判断 Dep.target 是否存在, 如果存在则会执行 dep.depend()。</p><p>这时候我们看到这里会有疑问, 首先 Dep 是什么? Dep.target 又是什么? dep.depend() 发挥了什么作用?</p><p>那接下来我们一个个来探索。</p><h2 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h2><p>我们先看下官方文档:</p><blockquote><p>每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。</p></blockquote><p>其实 Dep 就是用来收集当前组件的渲染 watcher, 并记录为依赖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dep的作用是建立起数据和watcher之间的桥梁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 静态属性</span></span><br><span class="line">  <span class="keyword">static</span> target: ?Watcher;</span><br><span class="line">  id: number;</span><br><span class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = uid++</span><br><span class="line">    <span class="keyword">this</span>.subs = [] <span class="comment">// 订阅当前数据变化的watcher</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(<span class="keyword">this</span>.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      <span class="comment">// 调用watcher.addDep</span></span><br><span class="line">      Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123;</span><br><span class="line">    ...省略</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局的watcher，同一时间只能有一个watcher被计算</span></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> targetStack = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">target: ?Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 把父级的watcher保存到栈结构中</span></span><br><span class="line">  targetStack.push(target)</span><br><span class="line">  Dep.target = target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">popTarget</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 恢复父级的watcher</span></span><br><span class="line">  targetStack.pop()</span><br><span class="line">  Dep.target = targetStack[targetStack.length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 src/core/observer/dep 中的代码定义了 Dep 这个类, 其构造函数初始化了一个 uid 和 subs 的空数组。接着我们看下 depend 这个函数, 其实现非常简单, 就是判断 Dep.target 是否存在, 存在则执行 Dep.target.addDep(this), 那这时候我们得要先知道 Dep.target 是什么东东。</p><p>Dep.target 是一个全局的渲染 watcher, 而且其保证同一时间只能有一个 watcher 被计算, 所以在 pushTarget 就是对把传入的渲染 watcher 赋值给 Dep.target, 并通过一个数组实现栈结构来保存当前的渲染 watcher, 为啥需要通过栈结构来保存这些渲染 watcher, 因为 Vue 在 mountComponent 每个组件初始化过程中会实例化一个渲染 Watcher, 组件的创建初始化是先父后子递归执行, 所以这里是为了保证父级的渲染 watcher 能够等子组件初始化完成后进行恢复, 恢复方法对应 popTarget。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  el: ?Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ...省略</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  ... 省略</span><br><span class="line"></span><br><span class="line">  updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    vm._update(vm._render(), hydrating)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">        callHook(vm, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，可能会有疑问, Dep.target 是什么时候进行赋值为当前的渲染 watcher 的呢?</p><h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><p>mountComponent 实例化了渲染 watcher, 我们看下  Watcher 的实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  ...省略</span><br><span class="line">  <span class="keyword">constructor</span> (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: ?Object,</span><br><span class="line">    isRenderWatcher?: boolean</span><br><span class="line">  ) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher = <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = !!options.deep</span><br><span class="line">      <span class="keyword">this</span>.user = !!options.user</span><br><span class="line">      <span class="keyword">this</span>.lazy = !!options.lazy</span><br><span class="line">      <span class="keyword">this</span>.sync = !!options.sync</span><br><span class="line">      <span class="keyword">this</span>.before = options.before</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = <span class="keyword">this</span>.user = <span class="keyword">this</span>.lazy = <span class="keyword">this</span>.sync = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="keyword">this</span>.id = ++uid <span class="comment">// uid for batching</span></span><br><span class="line">    <span class="keyword">this</span>.active = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy <span class="comment">// for lazy watchers</span></span><br><span class="line">    <span class="keyword">this</span>.deps = []</span><br><span class="line">    <span class="keyword">this</span>.newDeps = []</span><br><span class="line">    <span class="keyword">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">this</span>.expression = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line">      ? expOrFn.toString()</span><br><span class="line">      : <span class="string">''</span></span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">      ...省略</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy</span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">      : <span class="keyword">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluate the getter, and re-collect dependencies.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">get</span> () &#123;</span><br><span class="line">    <span class="comment">// 把当前的渲染watcher赋值给Dep.target</span></span><br><span class="line">    pushTarget(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 执行在mountComponet中传入的updateComponent</span></span><br><span class="line">      value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">        traverse(value)</span><br><span class="line">      &#125;</span><br><span class="line">      popTarget()</span><br><span class="line">      <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  ...省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Watcher 的构造函数初始化数据后，把传入的 expOrFn 回调函数进行函数转换, 并赋值给当前实例的 getter。最后执行了 this.get 函数, get 函数里面调用了 pushTarget(this) 把当前的渲染 watcher 实例赋值了 Dep.target, 看到这里就觉得 Vue 的设计模式是真的很巧妙。</p><p>depend 函数其实就是把当前的 Dep 实例传参执行当前渲染 watcher 的 addDep 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">addDep (dep: Dep) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = dep.id</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">    <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">      <span class="comment">// 把当前的watcher添加到dep的subs中，也就是当前的watcher作为订阅者</span></span><br><span class="line">      dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其功能就是把当前传入的 dep 实例 和 id 分布记录到 newDeps 和 newDepIds 的数组中, 然后再调用 dep 实例自身的 addSub, 把当前的渲染 watcher 实例添加到 dep 实例中的 subs 数组, 其实就是把当前的渲染 watcher 订阅到这个组件的数据对象持有的 dep 的 subs 中, 目的是为后续数据变化时候能通知到哪些 subs 做准备。</p><p>现在我们已经大概了解整个依赖收集的过程了, 这里还有一个问题, 就是我们一开始说的 getter 什么时候能够触发执行呢?</p><p>我们刚才已经看了 mountComponent 的源码, 其中 updateComponent 执行了 vm._render() 方法, 而 _render 会执行传入的 render 方法, 这时候会解析传入的数据, 从而触发对应数据对象的 getter 方法。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vue-logo.png&quot; alt=&quot;Vue&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;响应式对象Getter-Setter&quot;&gt;&lt;a href=&quot;#响应式对象Getter-Setter&quot; class=&quot;headerlink&quot; title=&quot;响应式对象G
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码浅析之响应式对象初始化</title>
    <link href="http://yoursite.com/2019/06/17/Vue%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90%E4%B9%8B%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2019/06/17/Vue源码浅析之响应式对象初始化/</id>
    <published>2019-06-16T17:48:11.000Z</published>
    <updated>2021-07-20T03:24:10.676Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vue-logo.png" alt="Vue"></p><h2 id="响应式对象简介"><a href="#响应式对象简介" class="headerlink" title="响应式对象简介"></a>响应式对象简介</h2><p>这里引用官方文档的解释：</p><blockquote><p>当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。</p></blockquote><p>根据上面的解释, 那这次我们来探索一下这个响应式对象的初始化过程, 也就是 Vue 如何把实例的 data 选项进行遍历并如何使用 Object.defineProperty 把属性转为 getter/setter。</p><h2 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h2><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123;user.name&#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      user: &#123;</span><br><span class="line">        name: <span class="string">''</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>假设我们用这个简单的示例来定义一个Vue的单文件组件, 这个组件在初始化的过程中会进行组件的注册创建, 通过 Vue.extend 获取组件的构造器, 最后把定义好的 options 传参并实例化 vm 对象, 这时候构造器的执行就会调用 _init 方法, 在 _init 方法中执行了 initState 方法, initState 方法执行了 initProps, initMethods, initData, initComputed, initWatch 等等方法。</p><p>那这次我们通过 initData 来一起探索下 data 属性是怎么转化定义 getter/setter, 然后这个过程又做了什么事情。</p><h2 id="响应式对象初始化-–-initData"><a href="#响应式对象初始化-–-initData" class="headerlink" title="响应式对象初始化 – initData"></a>响应式对象初始化 – initData</h2><p>我们来看下 initData 的源码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data</span><br><span class="line">  <span class="comment">// 把传入的 options 的 data 对象赋值到 vm._data</span></span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">'function'</span></span><br><span class="line">    ? getData(data, vm)</span><br><span class="line">    : data || &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ...省略</span><br><span class="line"></span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props</span><br><span class="line">  <span class="keyword">const</span> methods = vm.$options.methods</span><br><span class="line">  <span class="keyword">let</span> i = keys.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has already been defined as a data property.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断props和data的属性命名是否冲突</span></span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">`The data property "<span class="subst">$&#123;key&#125;</span>" is already declared as a prop. `</span> +</span><br><span class="line">        <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line">      <span class="comment">// vue实例代理属性</span></span><br><span class="line">      proxy(vm, <span class="string">`_data`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data 监测数据变化</span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们简单这看下, 一开始先判断传入的 options 的 data 属性是否为函数类型, 如果是则执行 getData 方法执行 data 函数获取对应的数据对象, 接着获取这个数据对象的 keys 并进行遍历, 这里遍历的目的有两个:</p><ul><li>对 data 和 props 进行属性命名校验检测</li><li>代理 vm 实例的属性获取到 vm._data, 这也就是我们为什么可以通过 this.user.name 获取到我们定义的数据对象的属性值。</li></ul><p>看完这里, 最后来到 observe 方法, 把 data 作为参数传入执行。</p><h2 id="响应式对象初始化-–-observe"><a href="#响应式对象初始化-–-observe" class="headerlink" title="响应式对象初始化 – observe"></a>响应式对象初始化 – observe</h2><p>observe 主要是用来监测数据变化, 也就是初始化响应式对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value: any, asRootData: ?boolean</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 非Vnode的对象类型才执行监听器初始化</span></span><br><span class="line">  <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span></span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    <span class="comment">// 对于已经挂载监听器的value直接返回</span></span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 把value传入Observer进行进行监听器实例化</span></span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.vmCount++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以很清楚看到, observer 通过判断当前的数据对象需要满足为非Vnode的对象类型才进行函数进一步执行, 接着这里通过判断当前的数据对象是否已经拥有 <strong>ob</strong> 的属性, 如果有就直接获取返回 value.<strong>ob</strong>, 没有则实例化一个 Observer 并传入数据对象。</p><p>到这里我们可以大致看出, 这个函数最后返回的 ob 其实就是响应式对象。它使得传入的数据对象会增加 <strong>ob</strong> 属性, 我们看下 Observer 是什么东东。</p><h2 id="响应式对象初始化-–-Observer"><a href="#响应式对象初始化-–-Observer" class="headerlink" title="响应式对象初始化 – Observer"></a>响应式对象初始化 – Observer</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observer 用于给对象的属性添加getter和setter，用于进行依赖收集和更新下发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; <span class="comment">// number of vms that have this object as root $data</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (value: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="keyword">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="keyword">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 把实例对象添加到数据对象中的__ob__</span></span><br><span class="line">    def(value, <span class="string">'__ob__'</span>, <span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        protoAugment(value, arrayMethods)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 数组类型遍历再次调用observe</span></span><br><span class="line">      <span class="keyword">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 遍历对象调用defineReactive</span></span><br><span class="line">      <span class="keyword">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Walk through all properties and convert them into</span></span><br><span class="line"><span class="comment">   * getter/setters. This method should only be called when</span></span><br><span class="line"><span class="comment">   * value type is Object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  observeArray (items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Observer 的够着函数通过 def 函数, 给传入的 value 这个数据对象定义 <strong>ob</strong> 属性, 而对应这个属性的值就当前这个 Observer 的实例化对象。 def 函数的功能我们可以看下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a property.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">def</span> (<span class="params">obj: Object, key: string, val: any, enumerable?: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    value: val,</span><br><span class="line">    enumerable: !!enumerable,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单, 就是调用 Object.defineProperty 来为 value 这个数据对象定义 <strong>ob</strong> 属性, 这里需要注意的是为什么要通过 Object.defineProperty, 而不直接通过 value.<strong>ob</strong> = this ? 先不揭晓答案, 我们只需要先注意这里 def 的调用中 !!enumerable 等同于 false, 也就是 <strong>ob</strong> 属性在 value 数据对象中是不可枚举的。</p><p>继续回到构造函数, 先判断 当前 value 是否为数组, 如果为数组就调用 this.observeArray(value) 来遍历value, 并对遍历的每一项进行递归调用 observe, 目的是保证数组的每一项都能初始化响应式对象。</p><p>如果不为数组, 那也就是 value 为对象类型, 调用 walk 方法来遍历 value 的属性。 这时候, 我们会发现如果我们刚才通过 value.<strong>ob</strong> = this 来定义 value 的 <strong>ob</strong> 属性, 会导致 <strong>ob</strong> 是可枚举, 这里遍历可以枚举出 <strong>ob</strong>, 但是 <strong>ob</strong> 我们没必要对其进行响应式对象初始化, 所以也就是为什么要通过 Object.defineProperty 把 <strong>ob</strong> 定义为不可枚举的属性。遍历过程其实就是把当前 value 的每个属性的值传参进行 defineReactive 调用。</p><h2 id="响应式对象初始化-–-defineReactive"><a href="#响应式对象初始化-–-defineReactive" class="headerlink" title="响应式对象初始化 – defineReactive"></a>响应式对象初始化 – defineReactive</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个响应式对象，动态添加getter和setter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="comment">// 获取对象的属性描述符</span></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们刚才调用了 defineReactive 传入 value 和 keys[i], 这时候会执行 val = obj[key], 于是 val 这时候其实就是 value[key], 也就是数据对象的子属性, 这时候我们发现又会递归调用 observe 来对子属性进行响应式对象的初始化, 当然前提是子属性为非vnode的对象类型。 接着就对 value 的各个属性进行 getter/setter 的定义了, 具体 getter 和 setter 的实现我们这里不展开, 所以响应式对象的遍历初始化就到此结束了。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vue-logo.png&quot; alt=&quot;Vue&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;响应式对象简介&quot;&gt;&lt;a href=&quot;#响应式对象简介&quot; class=&quot;headerlink&quot; title=&quot;响应式对象简介&quot;&gt;&lt;/a&gt;响应式对象简介&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码浅析之异步组件注册</title>
    <link href="http://yoursite.com/2019/06/13/Vue%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90%E4%B9%8B%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C/"/>
    <id>http://yoursite.com/2019/06/13/Vue源码浅析之异步组件注册/</id>
    <published>2019-06-13T14:44:09.000Z</published>
    <updated>2021-07-20T03:24:10.676Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/vue-logo.png" alt="Vue"></p><h2 id="Vue的异步组件注册"><a href="#Vue的异步组件注册" class="headerlink" title="Vue的异步组件注册"></a>Vue的异步组件注册</h2><p>Vue官方文档提供注册异步组件的方式有三种:</p><ol><li>工厂函数执行 resolve 回调</li><li>工厂函数中返回Promise</li><li>工厂函数返回一个配置化组件对象</li></ol><h2 id="工厂函数执行-resolve-回调"><a href="#工厂函数执行-resolve-回调" class="headerlink" title="工厂函数执行 resolve 回调"></a>工厂函数执行 resolve 回调</h2><p>我们看下 Vue 官方文档提供的示例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-webpack-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个特殊的 `require` 语法将会告诉 webpack</span></span><br><span class="line">  <span class="comment">// 自动将你的构建代码切割成多个包, 这些包</span></span><br><span class="line">  <span class="comment">// 会通过 Ajax 请求加载</span></span><br><span class="line">  <span class="built_in">require</span>([<span class="string">'./my-async-component'</span>], resolve)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>简单说明一下, 这个示例调用 Vue 的静态方法 component 实现组件注册, 需要了解下 Vue.component 的大致实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此时type为component</span></span><br><span class="line">Vue[type] = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  id: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  definition: Function | Object</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Function</span> | <span class="title">Object</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!definition) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.options[type + <span class="string">'s'</span>][id]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; type === <span class="string">'component'</span>) &#123;</span><br><span class="line">      validateComponentName(id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否为对象</span></span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">'component'</span> &amp;&amp; isPlainObject(definition)) &#123;</span><br><span class="line">      definition.name = definition.name || id</span><br><span class="line">      definition = <span class="keyword">this</span>.options._base.extend(definition)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">'directive'</span> &amp;&amp; <span class="keyword">typeof</span> definition === <span class="string">'function'</span>) &#123;</span><br><span class="line">      definition = &#123; <span class="attr">bind</span>: definition, <span class="attr">update</span>: definition &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录当前Vue的全局components, filters, directives对应的声明映射</span></span><br><span class="line">    <span class="keyword">this</span>.options[type + <span class="string">'s'</span>][id] = definition</span><br><span class="line">    <span class="keyword">return</span> definition</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断传入的 definition 也就是我们的工厂函数, 是否为对象, 都说是工厂函数了, 那肯定不为对象, 于是这里不调用 this.options._base.extend(definition) 来获取组件的构造函数, 而是直接把当前的 definition(工厂函数) 保存到 this.options.components 的 ‘async-webpack-example’ 属性值中, 并返回definition。</p><p>接下来发生什么事情呢？<br>其实刚才我们只是调用了 Vue.component 注册一个异步组件, 但是我们最终是通过 new Vue 实例来实现页面的渲染。这里大致浏览一下渲染的过程：</p><p>Run:</p><ul><li>new Vue执行构造函数 </li><li>构造函数 执行 this._init, 在 initMixin 执行的时候定义 Vue.prototype._init</li><li>$mount执行, 在 web/runtime/index.js 中已经进行定义 Vue.prototype.$mount</li><li>执行 core/instance/lifecycle.js 中的 mountComponent</li><li>实例化渲染Watcher, 并传入 updateComponent(通过 Watcher 实例对象的 getter 触发vm._update, 而至于怎么触发先忽略, 会另外讲解)</li><li>vm._update 触发 vm._render(renderMixin 时定义在 Vue.prototype._render) 执行</li><li>在 vm.$options 中获取 render 函数并执行, 使得传入的 vm.$createElement(在 initRender 中定义在vm中)执行, vm.$createElement也就是平时书写的 h =&gt; h(App)这个h函数。</li><li>vm.$createElement = createElement</li><li>createComponent 通过 resolveAsset 查询当前组件是否正常注册</li></ul><p>所以我们现在以及进入到 createComponent 这个函数了, 看下这里异步组件具体的实现逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  Ctor: Class&lt;Component&gt; | Function | Object | void,</span></span></span><br><span class="line"><span class="function"><span class="params">  data: ?VNodeData,</span></span></span><br><span class="line"><span class="function"><span class="params">  context: Component, <span class="regexp">//</span> vm实例</span></span></span><br><span class="line"><span class="function"><span class="params">  children: ?Array&lt;VNode&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag?: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; | <span class="title">void</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在init初始化的时候赋值Vue</span></span><br><span class="line">  <span class="keyword">const</span> baseCtor = context.$options._base</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ctor当前为异步组件的工厂函数, 所以此步骤不执行</span></span><br><span class="line">  <span class="keyword">if</span> (isObject(Ctor)) &#123;</span><br><span class="line">    <span class="comment">// 获取构造器, 对于非全局注册的组件使用</span></span><br><span class="line">    Ctor = baseCtor.extend(Ctor)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// async component</span></span><br><span class="line">  <span class="keyword">let</span> asyncFactory</span><br><span class="line">  <span class="comment">// 如果Ctro.cid为undefined, 则说明h会是异步组件注册</span></span><br><span class="line">  <span class="comment">// 原因是没有调用过 Vue.extend 进行组件构造函数转换获取</span></span><br><span class="line">  <span class="keyword">if</span> (isUndef(Ctor.cid)) &#123;</span><br><span class="line">    asyncFactory = Ctor</span><br><span class="line">    <span class="comment">// 解析异步组件</span></span><br><span class="line">    Ctor = resolveAsyncComponent(asyncFactory, baseCtor)</span><br><span class="line">    <span class="comment">// Ctor为undefined则直接创建并返回异步组件的占位符组件Vnode</span></span><br><span class="line">    <span class="keyword">if</span> (Ctor === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> createAsyncPlaceholder(</span><br><span class="line">        asyncFactory,</span><br><span class="line">        data,</span><br><span class="line">        context,</span><br><span class="line">        children,</span><br><span class="line">        tag</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...此处省略不分析的代码</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 安装组件的钩子</span></span><br><span class="line">  installComponentHooks(data)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return a placeholder vnode</span></span><br><span class="line">  <span class="keyword">const</span> name = Ctor.options.name || tag</span><br><span class="line">  <span class="keyword">const</span> vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">    <span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span><span class="subst">$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">''</span>&#125;</span>`</span>,</span><br><span class="line">    data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">    &#123; Ctor, propsData, listeners, tag, children &#125;, <span class="comment">// 组件对象componentOptions</span></span><br><span class="line">    asyncFactory</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码我们可以看出, 异步组件不执行组件构造器的转换获取, 而是执行 resolveAsyncComponent 来获取返回的组件构造器。由于该过程是异步请求组件, 所以我们看下 resolveAsyncComponent 的实现  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义在render.js中的全局变量, 用于记录当前正在渲染的vm实例</span></span><br><span class="line"><span class="keyword">import</span> &#123; currentRenderingInstance &#125; <span class="keyword">from</span> <span class="string">'core/instance/render'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveAsyncComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  factory: Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  baseCtor: Class&lt;Component&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Class</span>&lt;<span class="title">Component</span>&gt; | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 高级异步组件使用</span></span><br><span class="line">  <span class="keyword">if</span> (isTrue(factory.error) &amp;&amp; isDef(factory.errorComp)) &#123;...先省略&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isDef(factory.resolved)) &#123;</span><br><span class="line">    <span class="keyword">return</span> factory.resolved</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取当前正在渲染的vm实例</span></span><br><span class="line">  <span class="keyword">const</span> owner = currentRenderingInstance</span><br><span class="line">  <span class="keyword">if</span> (owner &amp;&amp; isDef(factory.owners) &amp;&amp; factory.owners.indexOf(owner) === <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// already pending</span></span><br><span class="line">    factory.owners.push(owner)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isTrue(factory.loading) &amp;&amp; isDef(factory.loadingComp)) &#123;...省略&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行该逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (owner &amp;&amp; !isDef(factory.owners)) &#123;</span><br><span class="line">    <span class="keyword">const</span> owners = factory.owners = [owner]</span><br><span class="line">    <span class="comment">// 用于标记是否</span></span><br><span class="line">    <span class="keyword">let</span> sync = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    ...省略</span><br><span class="line">    <span class="keyword">const</span> forceRender = <span class="function">(<span class="params">renderCompleted: boolean</span>) =&gt;</span> &#123; ...省略 &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// once让被once包装的任何函数的其中一个只执行一次</span></span><br><span class="line">    <span class="keyword">const</span> resolve = once(<span class="function">(<span class="params">res: <span class="built_in">Object</span> | Class&lt;Component&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// cache resolved</span></span><br><span class="line">      factory.resolved = ensureCtor(res, baseCtor)</span><br><span class="line">      <span class="comment">// invoke callbacks only if this is not a synchronous resolve</span></span><br><span class="line">      <span class="comment">// (async resolves are shimmed as synchronous during SSR)</span></span><br><span class="line">      <span class="keyword">if</span> (!sync) &#123;</span><br><span class="line">        forceRender(<span class="literal">true</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        owners.length = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> reject = once(<span class="function"><span class="params">reason</span> =&gt;</span> &#123; ...省略 &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行工厂函数, 比如webpack获取异步组件资源</span></span><br><span class="line">    <span class="keyword">const</span> res = factory(resolve, reject)</span><br><span class="line">    </span><br><span class="line">    ...省略</span><br><span class="line">    </span><br><span class="line">    sync = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// return in case resolved synchronously</span></span><br><span class="line">    <span class="keyword">return</span> factory.loading</span><br><span class="line">      ? factory.loadingComp</span><br><span class="line">      : factory.resolved</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resolveAsyncComponent 传入异步组件工厂函数和 baseCtor(也就是Vue.extend), 先获取当前渲染的vm实例接着标记sync为true, 表示当前为执行同步代码阶段, 定义 resolve 和 reject 函数(忽略不分析), 此时我们可以发现 resolve 和 reject 都被 once 函数所封装, 目的是让被 once 包装的任何函数的其中一个只执行一次, 保证 resolve 和 reject 两者只能择一并只执行一次。OK, 接着来到 factory 的执行, 其实就是执行官方示例中传入的工厂函数, 这时候发起异步组件的请求。同步代码继续执行, sync置位false, 表示当前的同步代码执行完毕, 然后返回undefined</p><p>这里可能会问怎么会返回undefined, 因为我们传入的工厂函数没有loading属性, 然后当前的 factory 也没有 resolved 属性。</p><p>接着回到 createComponent 的代码中:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isUndef(Ctor.cid)) &#123;</span><br><span class="line">    asyncFactory = Ctor</span><br><span class="line">    <span class="comment">// 解析异步组件</span></span><br><span class="line">    Ctor = resolveAsyncComponent(asyncFactory, baseCtor)</span><br><span class="line">    <span class="comment">// Ctor为undefined则直接创建并返回异步组件的占位符组件Vnode</span></span><br><span class="line">    <span class="keyword">if</span> (Ctor === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> createAsyncPlaceholder(</span><br><span class="line">        asyncFactory,</span><br><span class="line">        data,</span><br><span class="line">        context,</span><br><span class="line">        children,</span><br><span class="line">        tag</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>因为刚才说 resolveAsyncComponent 执行返回了undefined, 所以执行 createAsyncPlaceholder 创建注释vnode</p><p>这里可能还会问为什么要创建一个注释vnode, 提前揭晓答案: </p><p>因为先要返回一个占位的 vnode, 等待异步请求加载后执行 forceUpdate 重新渲染, 然后这个节点会被更新渲染成组件的节点。</p><p>那继续,  刚才答案说了, 当异步组件请求完成后, 则执行 resolve 并传入对应的异步组件, 这时候 factory.resolved 被赋值为 ensureCtor 执行的返回结果, 就是一个组件构造器, 然后这时候 sync 为 false, 所以执行 forceRender, 而 forceRender 其实就是调用 vm.$forceUpdate 实现如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$forceUpdate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">if</span> (vm._watcher) &#123;</span><br><span class="line">    vm._watcher.update()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$forceUpdate 执行渲染 watcher 的 update 方法, 于是我们又会执行 createComponent 的方法, 执行 resolveAsyncComponent, 这时候 factory.resolved 已经定义过了, 于是直接返回 factory.resolved 的组件构造器。 于是就执行 createComponent 的后续组件的渲染和 patch 逻辑了。组件渲染和 patch 这里先不展开。</p><p>于是整个异步组件的流程就结束了。</p><h2 id="工厂函数中返回Promise"><a href="#工厂函数中返回Promise" class="headerlink" title="工厂函数中返回Promise"></a>工厂函数中返回Promise</h2><p>先看下官网文档提供的示例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(</span><br><span class="line">  <span class="string">'async-webpack-example'</span>,</span><br><span class="line">  <span class="comment">// 这个 `import` 函数会返回一个 `Promise` 对象。</span></span><br><span class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>由上面的示例, 可以看到当调用Vue.component的时候, definition为一个会返回 Promise 的函数, 与工厂函数执行 resolve 回调不同的地方在于:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveAsyncComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  factory: Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  baseCtor: Class&lt;Component&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Class</span>&lt;<span class="title">Component</span>&gt; | <span class="title">void</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...省略</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行工厂函数, 比如webpack获取异步组件资源</span></span><br><span class="line">    <span class="keyword">const</span> res = factory(resolve, reject)</span><br><span class="line">    <span class="keyword">if</span> (isObject(res)) &#123;</span><br><span class="line">      <span class="comment">// 为Promise对象,  import('./async-component')</span></span><br><span class="line">      <span class="keyword">if</span> (isPromise(res)) &#123;</span><br><span class="line">        <span class="comment">// () =&gt; Promise</span></span><br><span class="line">        <span class="keyword">if</span> (isUndef(factory.resolved)) &#123;</span><br><span class="line">          res.then(resolve, reject)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPromise(res.component)) &#123;</span><br><span class="line">        res.component.then(resolve, reject)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isDef(res.error)) &#123;</span><br><span class="line">          factory.errorComp = ensureCtor(res.error, baseCtor)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isDef(res.loading)) &#123;</span><br><span class="line">          factory.loadingComp = ensureCtor(res.loading, baseCtor)</span><br><span class="line">          <span class="keyword">if</span> (res.delay === <span class="number">0</span>) &#123;</span><br><span class="line">            factory.loading = <span class="literal">true</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timerLoading = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              timerLoading = <span class="literal">null</span></span><br><span class="line">              <span class="keyword">if</span> (isUndef(factory.resolved) &amp;&amp; isUndef(factory.error)) &#123;</span><br><span class="line">                factory.loading = <span class="literal">true</span></span><br><span class="line">                forceRender(<span class="literal">false</span>)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, res.delay || <span class="number">200</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isDef(res.timeout)) &#123;</span><br><span class="line">          timerTimeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            timerTimeout = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">if</span> (isUndef(factory.resolved)) &#123;</span><br><span class="line">              reject(</span><br><span class="line">                process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line">                  ? <span class="string">`timeout (<span class="subst">$&#123;res.timeout&#125;</span>ms)`</span></span><br><span class="line">                  : <span class="literal">null</span></span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, res.timeout)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sync = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// return in case resolved synchronously</span></span><br><span class="line">    <span class="keyword">return</span> factory.loading</span><br><span class="line">      ? factory.loadingComp</span><br><span class="line">      : factory.resolved</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要不同点在于执行完 factory 工厂函数, 这时候我们的工厂函数会返回一个 Promise, 所以 res.then(resolve, reject) 会执行,  接下来的过程也是等待异步组件请求完成, 然后执行 resolve 函数, 接着执行 forceRender 然后返回组件构造器。</p><p>这里 Promise 写法的异步组件注册过程和执行回调函数没有太大的区别。</p><h2 id="工厂函数返回一个配置化组件对象"><a href="#工厂函数返回一个配置化组件对象" class="headerlink" title="工厂函数返回一个配置化组件对象"></a>工厂函数返回一个配置化组件对象</h2><p>同样, 看下官网示例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AsyncComponent = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// 需要加载的组件 (应该是一个 `Promise` 对象)</span></span><br><span class="line">  component: <span class="keyword">import</span>(<span class="string">'./MyComponent.vue'</span>),</span><br><span class="line">  <span class="comment">// 异步组件加载时使用的组件</span></span><br><span class="line">  loading: LoadingComponent,</span><br><span class="line">  <span class="comment">// 加载失败时使用的组件</span></span><br><span class="line">  error: ErrorComponent,</span><br><span class="line">  <span class="comment">// 展示加载时组件的延时时间。默认值是 200 (毫秒)</span></span><br><span class="line">  delay: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// 如果提供了超时时间且组件加载也超时了，</span></span><br><span class="line">  <span class="comment">// 则使用加载失败时使用的组件。默认值是：`Infinity`</span></span><br><span class="line">  timeout: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>从上面的示例可以看到, 工厂函数在执行成功后会返回一个配置对象, 这个对象的5个属性我们都可以从官方文档的注释了解到各自的作用。那我们看一下这种方式和前面提到的两种方式的区别在哪里.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveAsyncComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  factory: Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  baseCtor: Class&lt;Component&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Class</span>&lt;<span class="title">Component</span>&gt; | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 高级异步组件使用</span></span><br><span class="line">  <span class="keyword">if</span> (isTrue(factory.error) &amp;&amp; isDef(factory.errorComp)) &#123;</span><br><span class="line">    <span class="keyword">return</span> factory.errorComp</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isDef(factory.resolved)) &#123;</span><br><span class="line">    <span class="keyword">return</span> factory.resolved</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...已了解过，省略</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isTrue(factory.loading) &amp;&amp; isDef(factory.loadingComp)) &#123;</span><br><span class="line">    <span class="keyword">return</span> factory.loadingComp</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (owner &amp;&amp; !isDef(factory.owners)) &#123;</span><br><span class="line">    <span class="keyword">const</span> owners = factory.owners = [owner]</span><br><span class="line">    <span class="keyword">let</span> sync = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">let</span> timerLoading = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> timerTimeout = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    ;<span class="function">(<span class="params">owner: any</span>).<span class="params">$on</span>(<span class="params"><span class="string">'hook:destroyed'</span>, (</span>) =&gt;</span> remove(owners, owner))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> forceRender = <span class="function">(<span class="params">renderCompleted: boolean</span>) =&gt;</span> &#123;...省略&#125;</span><br><span class="line">    <span class="comment">// once让被once包装的任何函数的其中一个只执行一次</span></span><br><span class="line">    <span class="keyword">const</span> resolve = once(<span class="function">(<span class="params">res: <span class="built_in">Object</span> | Class&lt;Component&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">      factory.resolved = ensureCtor(res, baseCtor)</span><br><span class="line">      <span class="keyword">if</span> (!sync) &#123;</span><br><span class="line">        forceRender(<span class="literal">true</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        owners.length = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> reject = once(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">`Failed to resolve async component: <span class="subst">$&#123;<span class="built_in">String</span>(factory)&#125;</span>`</span> +</span><br><span class="line">        (reason ? <span class="string">`\nReason: <span class="subst">$&#123;reason&#125;</span>`</span> : <span class="string">''</span>)</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">if</span> (isDef(factory.errorComp)) &#123;</span><br><span class="line">        factory.error = <span class="literal">true</span></span><br><span class="line">        forceRender(<span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行工厂函数，比如webpack获取异步组件资源</span></span><br><span class="line">    <span class="keyword">const</span> res = factory(resolve, reject)</span><br><span class="line">    <span class="keyword">if</span> (isObject(res)) &#123;</span><br><span class="line">      <span class="comment">// 为Promise对象， import('./async-component')</span></span><br><span class="line">      <span class="keyword">if</span> (isPromise(res)) &#123;</span><br><span class="line">        ...省略</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPromise(res.component)) &#123;</span><br><span class="line">        res.component.then(resolve, reject)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isDef(res.error)) &#123;</span><br><span class="line">          factory.errorComp = ensureCtor(res.error, baseCtor)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isDef(res.loading)) &#123;</span><br><span class="line">          factory.loadingComp = ensureCtor(res.loading, baseCtor)</span><br><span class="line">          <span class="keyword">if</span> (res.delay === <span class="number">0</span>) &#123;</span><br><span class="line">            factory.loading = <span class="literal">true</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timerLoading = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">              timerLoading = <span class="literal">null</span></span><br><span class="line">              <span class="keyword">if</span> (isUndef(factory.resolved) &amp;&amp; isUndef(factory.error)) &#123;</span><br><span class="line">                factory.loading = <span class="literal">true</span></span><br><span class="line">                forceRender(<span class="literal">false</span>)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, res.delay || <span class="number">200</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isDef(res.timeout)) &#123;</span><br><span class="line">          timerTimeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            timerTimeout = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">if</span> (isUndef(factory.resolved)) &#123;</span><br><span class="line">              reject(</span><br><span class="line">                process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line">                  ? <span class="string">`timeout (<span class="subst">$&#123;res.timeout&#125;</span>ms)`</span></span><br><span class="line">                  : <span class="literal">null</span></span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, res.timeout)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sync = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// return in case resolved synchronously</span></span><br><span class="line">    <span class="keyword">return</span> factory.loading</span><br><span class="line">      ? factory.loadingComp</span><br><span class="line">      : factory.resolved</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染过程同样来到 resolveAsyncComponent, 一开始判断 factory.error 是否为 true, 当然一开始肯定是 false 的, 不进入该逻辑, 接着同样执行到 const res = factory(resolve, reject) 的执行, 因为我们刚才说了我们的工厂函数返回了一个异步组件配置对象, 于是 res 就是我们定义该工厂函数返回的对象, 这时候 isObject(res) 为 true, isPromise(res) 为 false, isPromise(res.component) 为 true, 接着判断 res.error 是否有定义, 于是在 factory 定义扩展了 errorComp, errorComp是通过 ensureCtor 来对 res.error 的定义组件转化为组件的构造器, loading 也是一样的逻辑, 在 factory 扩展 loadingComp 组件构造器。</p><p>接着, 这时候需要特别注意, 当我们定义的 res.delay 为 0, 则直接把 factory.loading 置为 true, 因为这里影响到 resolveAsyncComponent 的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> factory.loading</span><br><span class="line">      ? factory.loadingComp</span><br><span class="line">      : factory.resolved</span><br></pre></td></tr></table></figure><p>当 factory.loading 为 true, 会返回 loadingComp, 使得 createComponet 的时候不是创建一个注释vnode, 而是直接执行 loadingComp 的渲染。</p><p>如果我们的 res.delay 不为0, 则会启用一个计时器, 先同步返回 undefined 触发注释节点创建, 在一定的时间后执行 factory.loading = true 和 forceRender(false), 条件是组件没有加载完成以及没有出错 reject, 接着执行把注释vnode 替换为加载过程组件 loadingComp 的渲染。</p><p>而 res.timeout 主要用来计时, 当在 res.timeout 的时间内, 如果当前的 factory.resolved 为 undefined, 则说明异步组件加载已经超时了, 于是会调用 reject 方法, reject 其实就是调用 forceRender 来执行 errorComp 的渲染。</p><p>OK, 当我们的组件加载完成了, 执行了 resolve 方法, factory.resloved 置为 true, 调用 forceRender 来把注释节点或者是 loadingComp 的节点替换渲染为加载完成的组件。</p><p>到此, 我们已经了解三种异步组件的注册过程了。</p><h2 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h2><p>异步组件的渲染本质上其实就是执行2次或者2次以上的渲染, 先把当前组件渲染为注释节点, 当组件加载成功后, 通过 forceRender 执行重新渲染。或者是渲染为注释节点, 然后再渲染为loading节点, 在渲染为请求完成的组件。</p><p>这里需要注意的是 forceRender 的执行, forceRender 用于强制执行当前的节点重新渲染, 至于整个渲染过程是怎么样的后续文章有机会的话。。。再讲解吧。</p><p>本人语文表达能力有限, 只是突发奇想为了把自己了解到的过程用自己的话语表达出来, 如果有什么错误的地方望多多包涵。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/vue-logo.png&quot; alt=&quot;Vue&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Vue的异步组件注册&quot;&gt;&lt;a href=&quot;#Vue的异步组件注册&quot; class=&quot;headerlink&quot; title=&quot;Vue的异步组件注册&quot;&gt;&lt;/a&gt;Vue的异步
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>前端必备知识库之ES6篇</title>
    <link href="http://yoursite.com/2019/04/25/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E5%BA%93%E4%B9%8BES6%E7%AF%87/"/>
    <id>http://yoursite.com/2019/04/25/前端必备知识库之ES6篇/</id>
    <published>2019-04-24T17:20:06.000Z</published>
    <updated>2021-07-20T03:24:10.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="声明-let、const"><a href="#声明-let、const" class="headerlink" title="声明 let、const"></a>声明 let、const</h2><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><h2 id="声明类与继承：class、extend"><a href="#声明类与继承：class、extend" class="headerlink" title="声明类与继承：class、extend"></a>声明类与继承：class、extend</h2><h2 id="Promise的使用与实现"><a href="#Promise的使用与实现" class="headerlink" title="Promise的使用与实现"></a>Promise的使用与实现</h2><h2 id="generator（异步编程、yield、next-、await-、async）"><a href="#generator（异步编程、yield、next-、await-、async）" class="headerlink" title="generator（异步编程、yield、next()、await 、async）"></a>generator（异步编程、yield、next()、await 、async）</h2><h2 id="箭头函数this指向问题、拓展运算符"><a href="#箭头函数this指向问题、拓展运算符" class="headerlink" title="箭头函数this指向问题、拓展运算符"></a>箭头函数this指向问题、拓展运算符</h2><h2 id="map和set有没有用过，如何实现一个数组去重，map数据结构有什么优点？"><a href="#map和set有没有用过，如何实现一个数组去重，map数据结构有什么优点？" class="headerlink" title="map和set有没有用过，如何实现一个数组去重，map数据结构有什么优点？"></a>map和set有没有用过，如何实现一个数组去重，map数据结构有什么优点？</h2><h2 id="ES6怎么编译成ES5-css-loader原理-过程"><a href="#ES6怎么编译成ES5-css-loader原理-过程" class="headerlink" title="ES6怎么编译成ES5,css-loader原理,过程"></a>ES6怎么编译成ES5,css-loader原理,过程</h2><h2 id="ES6转成ES5的常见例子"><a href="#ES6转成ES5的常见例子" class="headerlink" title="ES6转成ES5的常见例子"></a>ES6转成ES5的常见例子</h2><h3 id="使用es5实现es6的class"><a href="#使用es5实现es6的class" class="headerlink" title="使用es5实现es6的class"></a>使用es5实现es6的class</h3><p>缓慢补充中~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;声明-let、const&quot;&gt;&lt;a href=&quot;#声明-let、const&quot; class=&quot;headerlink&quot; title=&quot;声明 let、const&quot;&gt;&lt;/a&gt;声明 let、const&lt;/h2&gt;&lt;h2 id=&quot;解构赋值&quot;&gt;&lt;a href=&quot;#解构赋值&quot; cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端必备知识库之Js篇</title>
    <link href="http://yoursite.com/2019/04/25/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E5%BA%93%E4%B9%8BJs%E7%AF%87/"/>
    <id>http://yoursite.com/2019/04/25/前端必备知识库之Js篇/</id>
    <published>2019-04-24T17:17:18.000Z</published>
    <updated>2021-07-20T03:24:10.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型-原型链-构造函数-实例-继承"><a href="#原型-原型链-构造函数-实例-继承" class="headerlink" title="原型/原型链/构造函数/实例/继承"></a>原型/原型链/构造函数/实例/继承</h2><h2 id="有几种方式可以实现继承"><a href="#有几种方式可以实现继承" class="headerlink" title="有几种方式可以实现继承"></a>有几种方式可以实现继承</h2><h2 id="用原型实现继承有什么缺点，怎么解决"><a href="#用原型实现继承有什么缺点，怎么解决" class="headerlink" title="用原型实现继承有什么缺点，怎么解决"></a>用原型实现继承有什么缺点，怎么解决</h2><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><h2 id="数据类型判断"><a href="#数据类型判断" class="headerlink" title="数据类型判断"></a>数据类型判断</h2><h2 id="作用域链、闭包、作用域"><a href="#作用域链、闭包、作用域" class="headerlink" title="作用域链、闭包、作用域"></a>作用域链、闭包、作用域</h2><h2 id="Ajax的原生写法"><a href="#Ajax的原生写法" class="headerlink" title="Ajax的原生写法"></a>Ajax的原生写法</h2><h2 id="对象深拷贝、浅拷贝"><a href="#对象深拷贝、浅拷贝" class="headerlink" title="对象深拷贝、浅拷贝"></a>对象深拷贝、浅拷贝</h2><h2 id="图片懒加载、预加载"><a href="#图片懒加载、预加载" class="headerlink" title="图片懒加载、预加载"></a>图片懒加载、预加载</h2><h2 id="实现页面加载进度条"><a href="#实现页面加载进度条" class="headerlink" title="实现页面加载进度条"></a>实现页面加载进度条</h2><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><h2 id="手动实现parseInt"><a href="#手动实现parseInt" class="headerlink" title="手动实现parseInt"></a>手动实现parseInt</h2><h2 id="为什么会有同源策略"><a href="#为什么会有同源策略" class="headerlink" title="为什么会有同源策略"></a>为什么会有同源策略</h2><h2 id="怎么判断两个对象是否相等"><a href="#怎么判断两个对象是否相等" class="headerlink" title="怎么判断两个对象是否相等"></a>怎么判断两个对象是否相等</h2><h2 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h2><h3 id="事件委托、代理"><a href="#事件委托、代理" class="headerlink" title="事件委托、代理"></a>事件委托、代理</h3><h3 id="如何让事件先冒泡后捕获"><a href="#如何让事件先冒泡后捕获" class="headerlink" title="如何让事件先冒泡后捕获"></a>如何让事件先冒泡后捕获</h3><h2 id="window的onload事件和domcontentloaded"><a href="#window的onload事件和domcontentloaded" class="headerlink" title="window的onload事件和domcontentloaded"></a>window的onload事件和domcontentloaded</h2><h2 id="for…in迭代和for…of有什么区别"><a href="#for…in迭代和for…of有什么区别" class="headerlink" title="for…in迭代和for…of有什么区别"></a>for…in迭代和for…of有什么区别</h2><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><h2 id="call-apply区别，原生实现bind"><a href="#call-apply区别，原生实现bind" class="headerlink" title="call apply区别，原生实现bind"></a>call apply区别，原生实现bind</h2><h3 id="call，apply，bind-三者用法和区别：角度可为参数、绑定规则（显示绑定和强绑定），运行效率、运行情况。"><a href="#call，apply，bind-三者用法和区别：角度可为参数、绑定规则（显示绑定和强绑定），运行效率、运行情况。" class="headerlink" title="call，apply，bind 三者用法和区别：角度可为参数、绑定规则（显示绑定和强绑定），运行效率、运行情况。"></a>call，apply，bind 三者用法和区别：角度可为参数、绑定规则（显示绑定和强绑定），运行效率、运行情况。</h3><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><h2 id="立即执行函数和使用场景"><a href="#立即执行函数和使用场景" class="headerlink" title="立即执行函数和使用场景"></a>立即执行函数和使用场景</h2><h2 id="设计模式-要求说出如何实现-应用-优缺点-单例模式实现"><a href="#设计模式-要求说出如何实现-应用-优缺点-单例模式实现" class="headerlink" title="设计模式(要求说出如何实现,应用,优缺点)/单例模式实现"></a>设计模式(要求说出如何实现,应用,优缺点)/单例模式实现</h2><h2 id="iframe的缺点有哪些"><a href="#iframe的缺点有哪些" class="headerlink" title="iframe的缺点有哪些"></a>iframe的缺点有哪些</h2><h2 id="数组问题"><a href="#数组问题" class="headerlink" title="数组问题"></a>数组问题</h2><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><h3 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h3><h3 id="查找数组重复项"><a href="#查找数组重复项" class="headerlink" title="查找数组重复项"></a>查找数组重复项</h3><h3 id="扁平化数组"><a href="#扁平化数组" class="headerlink" title="扁平化数组"></a>扁平化数组</h3><h3 id="按数组中各项和特定值差值排序"><a href="#按数组中各项和特定值差值排序" class="headerlink" title="按数组中各项和特定值差值排序"></a>按数组中各项和特定值差值排序</h3><h2 id="BOM属性对象方法"><a href="#BOM属性对象方法" class="headerlink" title="BOM属性对象方法"></a>BOM属性对象方法</h2><h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><h2 id="eventloop"><a href="#eventloop" class="headerlink" title="eventloop"></a>eventloop</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><h2 id="如何快速让字符串变成已千为精度的数字"><a href="#如何快速让字符串变成已千为精度的数字" class="headerlink" title="如何快速让字符串变成已千为精度的数字"></a>如何快速让字符串变成已千为精度的数字</h2><p>缓慢补充中~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原型-原型链-构造函数-实例-继承&quot;&gt;&lt;a href=&quot;#原型-原型链-构造函数-实例-继承&quot; class=&quot;headerlink&quot; title=&quot;原型/原型链/构造函数/实例/继承&quot;&gt;&lt;/a&gt;原型/原型链/构造函数/实例/继承&lt;/h2&gt;&lt;h2 id=&quot;有几种方式
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端必备知识库之Html篇</title>
    <link href="http://yoursite.com/2019/04/25/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E5%BA%93%E4%B9%8BHtml%E7%AF%87/"/>
    <id>http://yoursite.com/2019/04/25/前端必备知识库之Html篇/</id>
    <published>2019-04-24T17:16:20.000Z</published>
    <updated>2021-07-20T03:24:10.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h2><h2 id="新标签新特性"><a href="#新标签新特性" class="headerlink" title="新标签新特性"></a>新标签新特性</h2><h2 id="input和textarea的区别"><a href="#input和textarea的区别" class="headerlink" title="input和textarea的区别"></a>input和textarea的区别</h2><h2 id="用一个div模拟textarea的实现"><a href="#用一个div模拟textarea的实现" class="headerlink" title="用一个div模拟textarea的实现"></a>用一个div模拟textarea的实现</h2><h2 id="移动设备忽略将页面中的数字识别为电话号码的方法"><a href="#移动设备忽略将页面中的数字识别为电话号码的方法" class="headerlink" title="移动设备忽略将页面中的数字识别为电话号码的方法"></a>移动设备忽略将页面中的数字识别为电话号码的方法</h2><p>缓慢补充中~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;语义化&quot;&gt;&lt;a href=&quot;#语义化&quot; class=&quot;headerlink&quot; title=&quot;语义化&quot;&gt;&lt;/a&gt;语义化&lt;/h2&gt;&lt;h2 id=&quot;新标签新特性&quot;&gt;&lt;a href=&quot;#新标签新特性&quot; class=&quot;headerlink&quot; title=&quot;新标签新特性&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Html" scheme="http://yoursite.com/tags/Html/"/>
    
  </entry>
  
  <entry>
    <title>前端必备知识库之CSS篇</title>
    <link href="http://yoursite.com/2019/04/25/%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%E5%BA%93%E4%B9%8BCSS%E7%AF%87/"/>
    <id>http://yoursite.com/2019/04/25/前端必备知识库之CSS篇/</id>
    <published>2019-04-24T17:13:52.000Z</published>
    <updated>2021-07-20T03:24:10.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>盒子模型有两种，标准模型和IE盒模型</p><p><img src="/images/标准模型.png" alt="标准模型"><br><img src="/images/IE模型.png" alt="IE模型"></p><p>标准模型：宽高部分只包含content部分<br>IE模型： 宽高包含content + padding + border</p><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><h2 id="css单位"><a href="#css单位" class="headerlink" title="css单位"></a>css单位</h2><h2 id="css选择器"><a href="#css选择器" class="headerlink" title="css选择器"></a>css选择器</h2><h2 id="bfc-清除浮动"><a href="#bfc-清除浮动" class="headerlink" title="bfc 清除浮动"></a>bfc 清除浮动</h2><h2 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h2><h2 id="常见页面布局"><a href="#常见页面布局" class="headerlink" title="常见页面布局"></a>常见页面布局</h2><h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><h2 id="css预处理，后处理"><a href="#css预处理，后处理" class="headerlink" title="css预处理，后处理"></a>css预处理，后处理</h2><h2 id="css3新特性"><a href="#css3新特性" class="headerlink" title="css3新特性"></a>css3新特性</h2><h2 id="animation和transiton的相关属性"><a href="#animation和transiton的相关属性" class="headerlink" title="animation和transiton的相关属性"></a>animation和transiton的相关属性</h2><h2 id="animate和translate"><a href="#animate和translate" class="headerlink" title="animate和translate"></a>animate和translate</h2><h2 id="display哪些取值"><a href="#display哪些取值" class="headerlink" title="display哪些取值"></a>display哪些取值</h2><h2 id="相邻的两个inline-block节点为什么会出现间隔，该如何解决"><a href="#相邻的两个inline-block节点为什么会出现间隔，该如何解决" class="headerlink" title="相邻的两个inline-block节点为什么会出现间隔，该如何解决"></a>相邻的两个inline-block节点为什么会出现间隔，该如何解决</h2><h2 id="meta-viewport-移动端适配"><a href="#meta-viewport-移动端适配" class="headerlink" title="meta viewport 移动端适配"></a>meta viewport 移动端适配</h2><h2 id="CSS实现宽度自适应100-，宽高16-9的比例的矩形"><a href="#CSS实现宽度自适应100-，宽高16-9的比例的矩形" class="headerlink" title="CSS实现宽度自适应100%，宽高16:9的比例的矩形"></a>CSS实现宽度自适应100%，宽高16:9的比例的矩形</h2><h2 id="rem布局的优缺点"><a href="#rem布局的优缺点" class="headerlink" title="rem布局的优缺点"></a>rem布局的优缺点</h2><h2 id="画三角形"><a href="#画三角形" class="headerlink" title="画三角形"></a>画三角形</h2><h2 id="1像素边框问题"><a href="#1像素边框问题" class="headerlink" title="1像素边框问题"></a>1像素边框问题</h2><p>缓慢补充中~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;盒模型&quot;&gt;&lt;a href=&quot;#盒模型&quot; class=&quot;headerlink&quot; title=&quot;盒模型&quot;&gt;&lt;/a&gt;盒模型&lt;/h2&gt;&lt;p&gt;盒子模型有两种，标准模型和IE盒模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/标准模型.png&quot; alt=&quot;标准模型&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Css" scheme="http://yoursite.com/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存中的HTTP缓存</title>
    <link href="http://yoursite.com/2019/04/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E4%B8%AD%E7%9A%84HTTP%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2019/04/22/浏览器缓存中的HTTP缓存/</id>
    <published>2019-04-22T14:30:06.000Z</published>
    <updated>2021-07-20T03:24:10.676Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>缓存是一把双刃剑，既能帮你，也会害你。正确地使用缓存策略，能够让用户访问网页的速度大幅提升。</p></blockquote><p><img src="/images/cache.png" alt="cache"></p><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。</p><h2 id="缓存带来的优点"><a href="#缓存带来的优点" class="headerlink" title="缓存带来的优点"></a>缓存带来的优点</h2><ul><li>减少网络请求延迟，提高页面访问速度</li><li>降低服务器请求压力</li><li>减少网络带宽的消耗，比如资源存放cdn的情况，减少带宽的使用，有效降低成本。</li></ul><h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><p>常见的HTTP缓存只能缓存 GET 响应，对于其他类型的响应比如 (post, put, delete) 则无能为力。</p><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>强缓存是指通过使用Http的响应头 Expires 或 Cache-Control 对资源进行缓存有效期进行设置。两者都是通过控制资源的有效期来实现缓存策略，当对应的资源在有效期内命中，浏览器则不向后端发送通信，直接使用缓存策略命中的资源，一般浏览器会显示 from dist cache 和 from memory cache 两种。</p><p>这两者该如何去使用呢？有什么区别？</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>Expires是Http 1.0的产物，其实用法是后端在Http的响应头设置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expires: Apr, 22 2019 23:58:12 GMT</span><br></pre></td></tr></table></figure></p><p>其中是通过设置了一个时间戳，浏览器下次进行资源获取的时候会对比当前时间和此时间戳，如果当前时间小于该时间戳，就表示缓存仍在有效期中命中。如果要让缓存失效，则配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expires: -1</span><br></pre></td></tr></table></figure><p>由以上可发现问题，Expires依赖客户端本地时间，如果客户端的本地时间错误，就会让缓存策略失效，于是Http 1.1就新增了 Cache-Control 来替代 Expires。</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>Cache-Control 可配置的字段比较多，我们逐个来了解</p><p>no-cache: 强制确认缓存，浏览器获取资源时，浏览器都要向服务器进行通信验证缓存是否命中。</p><p>no-store: 禁止进行缓存， 强制浏览器在任何情况下都不要保留任何副本，也就是不进行任何缓存策略。</p><p>public: 公共缓存，任何路径的缓存者（CDN、代理服务器），可以无条件的缓存改资源。</p><p>private: 私有缓存，只针对单个用户或者实体（不同用户、窗口）缓存资源。</p><p>max-age=<seconds>: 通过设置时间长度 max-age，表示距离请求发起的时间的秒数，判断该资源在此时间范围内以内是否命中，避免时间戳带来的问题。</seconds></p><p>s-maxage=<seconds>: s-maxage 优先级高于 max-age，s-maxage 用于表示 cache 服务器上（比如 CDN）的缓存的有效时间，并只对 public 缓存有效。</seconds></p><p>可见 Cache-Control 的功能比 Expires 完善，而且优先级更高。</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>协商缓存依赖于浏览器于服务器端进行通信，浏览器需要向服务器询问当前资源是否命中缓存有效期。当请求讯问的资源命中缓存，则服务器会返回Http响应码304务端告知浏览器缓存资源命中，请求会被重定向到浏览器缓存。</p><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>服务器在首次返回资源的响应中通过设置响应头 Last-Modified 当前的时间戳</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Apr, 22 2019 23:58:12 GMT</span><br></pre></td></tr></table></figure><p>浏览器下次重新获取资源时与服务器进行通信进行协商缓存命中确认，会带上请求头 If-Modified-Since</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Apr, 22 2019 23:58:12 GMT</span><br></pre></td></tr></table></figure><p>服务器接收到 If-Modified-Since 的时间戳后，比对次时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值；否则，则命中缓存，返回 304 响应，并且响应头不会再添加 Last-Modified 字段。</p><p>Last-Modified 存在一定的弊端，一个是，当编辑后的资源内容没有改变，但服务器端会认为资源被更新，因为其判断是根据文件最后编辑时间。另一个是，当修改文件速度很快，而 If-Modified-Since 的时间戳和与最后修改时间的差距无法被计算出来，所以会认为资源没有进行更新。</p><h3 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h3><p>服务器首次返回资源设置响应头 ETag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: W/&quot;2123-420d462f951&quot;</span><br></pre></td></tr></table></figure><p>浏览器下次重新获取资源时与服务器进行通信进行协商缓存命中确认，会带上请求头 If-None-Match</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match: W/&quot;2123-420d462f951&quot;</span><br></pre></td></tr></table></figure><p>服务器接收到 If-None-Match 的资源标识后，比对当前服务器资源的标识和 If-None-Match 的资源标识是否一样，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 ETag 值；否则，则命中缓存，返回 304 响应，并且响应头不会再添加 ETag 字段。</p><p>Etag通过对资源进行内容的HASH计算，生成资源的标识。这样可以有效的避免 Last-Modified 的弊端，但 Etag 依赖于服务器端进行计算，会影响服务器性能。</p><p>最后用一张图标总结所有：</p><p><img src="/images/cache-process.png" alt="cache-process"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;缓存是一把双刃剑，既能帮你，也会害你。正确地使用缓存策略，能够让用户访问网页的速度大幅提升。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/images/cache.png&quot; alt=&quot;cache&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;浏览
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Http" scheme="http://yoursite.com/tags/Http/"/>
    
      <category term="Browser" scheme="http://yoursite.com/tags/Browser/"/>
    
  </entry>
  
  <entry>
    <title>2019我和前端有一个约定</title>
    <link href="http://yoursite.com/2019/04/22/2019%E6%88%91%E5%92%8C%E5%89%8D%E7%AB%AF%E6%9C%89%E4%B8%80%E4%B8%AA%E7%BA%A6%E5%AE%9A/"/>
    <id>http://yoursite.com/2019/04/22/2019我和前端有一个约定/</id>
    <published>2019-04-21T16:59:33.000Z</published>
    <updated>2021-07-20T03:24:10.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="规范简介"><a href="#规范简介" class="headerlink" title="规范简介"></a>规范简介</h2><blockquote><p>该规范目的是保证前端代码的整洁性和代码风格一致性，提高代码的可读性和可维护性。</p></blockquote><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><h3 id="项目命名"><a href="#项目命名" class="headerlink" title="项目命名"></a>项目命名</h3><p>全部采用小写方式，使用中划线 - 进行分隔</p><h3 id="目录结构规范"><a href="#目录结构规范" class="headerlink" title="目录结构规范"></a>目录结构规范</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"> |-- src</span><br><span class="line"> |    |-- libs // 公用的库文件，例如：主题样式，鉴权插件，定制化的图表库</span><br><span class="line"> |    |-- assets // 资源目录，比如png，jpg，svg图片等</span><br><span class="line"> |    |    |-- images</span><br><span class="line"> |    |         |-- svg // svg的图片单独放一个目录</span><br><span class="line"> |    |-- components // 通用的自定义组件</span><br><span class="line"> |    |-- pages // 页面</span><br><span class="line"> |-- config // webpack等前端配置文件</span><br></pre></td></tr></table></figure><h3 id="目录文件命名规范（推荐2种）"><a href="#目录文件命名规范（推荐2种）" class="headerlink" title="目录文件命名规范（推荐2种）"></a>目录文件命名规范（推荐2种）</h3><ul><li>目录和文件都使用小写单词并使用中划线 - 进行分隔</li><li>目录和文件使用小写单词并使用中划线 - 进行分隔，唯独.vue组件使用大驼峰进行命名<h3 id="package-json管理"><a href="#package-json管理" class="headerlink" title="package.json管理"></a>package.json管理</h3></li><li><p>对于项目中代码需要依赖引入的使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i vue -S</span><br></pre></td></tr></table></figure></li><li><p>对于项目中开发环境下进行运行调试压缩编译的使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i wepack -D</span><br></pre></td></tr></table></figure></li><li><p>对于npm包的管理一定要规范，不需要引入的不要随便安装并写入package.json文件，当需要引入新的依赖需要告知所有的项目成员。</p></li><li>npm的依赖包的版本需要谨慎操作，不要随便进行任意升级。中间版本号和小版本号可以进行定期升级，并commit对应的修改以及通知项目成员。而大版本号需要确定其版本是否兼容目前使用的版本并进行仔细的测试才可以提交修改。<h2 id="HTML书写规范"><a href="#HTML书写规范" class="headerlink" title="HTML书写规范"></a>HTML书写规范</h2><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3></li><li>使用2个空格进行缩进</li><li>嵌套的节点应该使用缩进</li><li>节点属性使用双引号，而不用单引号</li><li><p>非自动闭合的HTML元素一定要使用斜线进行闭合！！！，自动闭合HTML元素则可选, 举例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/logo.png"</span> <span class="attr">alt</span>=<span class="string">"logo"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>对于HTML 元素属性大于3个，推荐使用如下方式(适用于vue模板)，避免代码横向增长：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"switch-btn"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">:class</span>=<span class="string">"switchBtnIcon"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">:style</span>=<span class="string">"switchBtnLeftDistance"</span></span></span><br><span class="line"><span class="tag">   @<span class="attr">click</span>=<span class="string">"changeVisible"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h3><ul><li>根据使用场景选择正确的 HTML 元素。例如，使用 h1 元素创建标题，p 元素创建段落，a 元素创建链接，i 元素创建图标等等。正确的使用 HTML 元素对于可访问性、可重用性以及编码效率都很重要。<h3 id="资源引入"><a href="#资源引入" class="headerlink" title="资源引入"></a>资源引入</h3></li><li>引入资源使用相对路径，不要指定资源所带的具体协议 ( http:,https: ) ，除非这两者协议都不可用。<br>示例：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//ticket1000-1253841380.file.myqcloud.com/assets/release/vue/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="优化Dom结构"><a href="#优化Dom结构" class="headerlink" title="优化Dom结构"></a>优化Dom结构</h3><ul><li>尽量避免多余的父节点，通过迭代和重构来使HTML元素变得更少。<h3 id="属性顺序"><a href="#属性顺序" class="headerlink" title="属性顺序"></a>属性顺序</h3></li><li>class</li><li>id</li><li>name</li><li>data-*</li><li>src,for,type,href,value,max-length,max,min,pattern</li><li>placeholder,title,alt</li><li>aria-*,role</li><li>required,readonly,disabled<h2 id="CSS书写规范"><a href="#CSS书写规范" class="headerlink" title="CSS书写规范"></a>CSS书写规范</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3></li><li>类名使用小写字母，以中划线分隔</li><li>id采用驼峰式命名</li><li>less, scss中的变量、函数、混合、placeholder采用驼峰式命名<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3></li><li>每个属性声明末尾都要加分号</li><li>去掉小数点前面的0</li><li>去掉数字中不必要的小数点和末尾的0</li><li>属性值’0’后面不要加单位</li><li>用border: 0;代替border: none;</li><li>选择器不要超过4层</li><li>尽量少用’*’选择器<h3 id="需要加空格"><a href="#需要加空格" class="headerlink" title="需要加空格"></a>需要加空格</h3></li><li>属性值前</li><li>选择器 ‘&gt;’, ‘+’, ‘~’前后</li><li>‘{‘前</li><li>!important’!’前</li><li>@else前后</li><li>属性值中的’,’后</li><li>注释’/<em>‘后和’</em>/‘前<h3 id="需要换行"><a href="#需要换行" class="headerlink" title="需要换行"></a>需要换行</h3></li><li>‘{‘后和’}’前</li><li>每个属性独占一行</li><li>多个规则的分隔符’,’后<h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3></li><li>尽量使用16进制的颜色，当不需要控制透明度，避免使用rgba的写法。</li><li>16进制的颜色尽量使用简写代替<h3 id="属性顺序-1"><a href="#属性顺序-1" class="headerlink" title="属性顺序"></a>属性顺序</h3></li><li><p>简单示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.order</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e5e5e5</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">font</span>: normal <span class="number">13px</span> <span class="string">"Helvetica Neue"</span>, sans-serif;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f5f5f5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>完整顺序：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    [</span><br><span class="line">        <span class="string">"display"</span>,</span><br><span class="line">        <span class="string">"visibility"</span>,</span><br><span class="line">        <span class="string">"float"</span>,</span><br><span class="line">        <span class="string">"clear"</span>,</span><br><span class="line">        <span class="string">"overflow"</span>,</span><br><span class="line">        <span class="string">"clip"</span>,</span><br><span class="line">        <span class="string">"zoom"</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">"position"</span>,</span><br><span class="line">        <span class="string">"top"</span>,</span><br><span class="line">        <span class="string">"right"</span>,</span><br><span class="line">        <span class="string">"bottom"</span>,</span><br><span class="line">        <span class="string">"left"</span>,</span><br><span class="line">        <span class="string">"z-index"</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">"margin"</span>,</span><br><span class="line">        <span class="string">"box-sizing"</span>,</span><br><span class="line">        <span class="string">"border"</span>,</span><br><span class="line">        <span class="string">"border-radius"</span>,</span><br><span class="line">        <span class="string">"padding"</span>,</span><br><span class="line">        <span class="string">"width"</span>,</span><br><span class="line">        <span class="string">"height"</span>,</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">"font"</span>,</span><br><span class="line">        <span class="string">"line-height"</span>,</span><br><span class="line">        <span class="string">"text-align"</span>,</span><br><span class="line">        <span class="string">"vertical-align"</span>,</span><br><span class="line">        <span class="string">"white-space"</span>,</span><br><span class="line">        <span class="string">"text-decoration"</span>,</span><br><span class="line">        <span class="string">"word-spacing"</span>,</span><br><span class="line">        <span class="string">"text-overflow"</span>,</span><br><span class="line">        <span class="string">"word-wrap"</span>,</span><br><span class="line">        <span class="string">"word-break"</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">"color"</span>,</span><br><span class="line">        <span class="string">"background"</span>,</span><br><span class="line">        <span class="string">"background-color"</span>,</span><br><span class="line">        <span class="string">"background-image"</span>,</span><br><span class="line">        <span class="string">"background-repeat"</span>,</span><br><span class="line">        <span class="string">"background-attachment"</span>,</span><br><span class="line">        <span class="string">"background-position"</span>,</span><br><span class="line">        <span class="string">"background-clip"</span>,</span><br><span class="line">        <span class="string">"background-origin"</span>,</span><br><span class="line">        <span class="string">"background-size"</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">"outline"</span>,</span><br><span class="line">        <span class="string">"opacity"</span>,</span><br><span class="line">        <span class="string">"box-shadow"</span>,</span><br><span class="line">        <span class="string">"text-shadow"</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">"transition"</span>,</span><br><span class="line">        <span class="string">"transition-delay"</span>,</span><br><span class="line">        <span class="string">"transition-timing-function"</span>,</span><br><span class="line">        <span class="string">"transition-duration"</span>,</span><br><span class="line">        <span class="string">"transition-property"</span>,</span><br><span class="line">        <span class="string">"transform"</span>,</span><br><span class="line">        <span class="string">"transform-origin"</span>,</span><br><span class="line">        <span class="string">"animation"</span>,</span><br><span class="line">        <span class="string">"animation-duration"</span>,</span><br><span class="line">        <span class="string">"animation-delay"</span>,</span><br><span class="line">        <span class="string">"animation-direction"</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">"content"</span>,</span><br><span class="line">        <span class="string">"resize"</span>,</span><br><span class="line">        <span class="string">"cursor"</span>,</span><br><span class="line">        <span class="string">"user-select"</span>,</span><br><span class="line">        <span class="string">"tab-size"</span>,</span><br><span class="line">    ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><h2 id="JavaScript规范"><a href="#JavaScript规范" class="headerlink" title="JavaScript规范"></a>JavaScript规范</h2><ul><li>遵循<a href="https://standardjs.com/" target="_blank" rel="noopener">standardjs</a>规范<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://eslint.org/docs/user-guide/configuring</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    root: <span class="literal">true</span>,</span><br><span class="line">    parser: <span class="string">'babel-eslint'</span>,</span><br><span class="line">    parserOptions: &#123;</span><br><span class="line">        sourceType: <span class="string">'module'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    env: &#123;</span><br><span class="line">        browser: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style</span></span><br><span class="line">    extends: <span class="string">'standard'</span>,</span><br><span class="line">    <span class="comment">// required to lint *.vue files</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="string">'html'</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// add your custom rules here</span></span><br><span class="line">    <span class="string">'rules'</span>: &#123;</span><br><span class="line">        <span class="comment">// allow paren-less arrow functions</span></span><br><span class="line">        <span class="string">'arrow-parens'</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// allow async-await</span></span><br><span class="line">        <span class="string">'generator-star-spacing'</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// allow semi</span></span><br><span class="line">        <span class="string">'semi'</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// allow debugger during development</span></span><br><span class="line">        <span class="string">'no-debugger'</span>: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="number">2</span> : <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Vue规范"><a href="#Vue规范" class="headerlink" title="Vue规范"></a>Vue规范</h2><ul><li>请仔细阅读<a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="noopener">vue风格指南</a>!!!</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;规范简介&quot;&gt;&lt;a href=&quot;#规范简介&quot; class=&quot;headerlink&quot; title=&quot;规范简介&quot;&gt;&lt;/a&gt;规范简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;该规范目的是保证前端代码的整洁性和代码风格一致性，提高代码的可读性和可维护性。&lt;/p&gt;
&lt;/blo
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
      <category term="Css" scheme="http://yoursite.com/tags/Css/"/>
    
  </entry>
  
  <entry>
    <title>Vue和TypeScript的Webpack4.+尝鲜</title>
    <link href="http://yoursite.com/2018/05/26/Vue%E5%92%8CTypeScript%E7%9A%84Webpack4-%E5%B0%9D%E9%B2%9C/"/>
    <id>http://yoursite.com/2018/05/26/Vue和TypeScript的Webpack4-尝鲜/</id>
    <published>2018-05-26T10:12:45.000Z</published>
    <updated>2021-07-20T03:24:10.676Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/VuexStorageTS.png" alt="banner"></p><blockquote><p>静态类型系统能帮助你有效防止许多潜在的运行时错误，而且随着你的应用日渐丰满会更加显著。这就是为什么 Vue 不仅仅为 Vue core 提供了针对 TypeScript 的官方类型声明，还为 Vue Router 和 Vuex 也提供了相应的声明文件</p></blockquote><h2 id="TsConfig配置"><a href="#TsConfig配置" class="headerlink" title="TsConfig配置"></a>TsConfig配置</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">      <span class="comment">// ts 文件编译成 js 文件的时候，同时生成对应的 map 文件</span></span><br><span class="line">      <span class="string">"sourceMap"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">"strict"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">"strictNullChecks"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 当表达式和申明 类型为any时，是否需要发出警告，设置true，则不警告</span></span><br><span class="line">      <span class="string">"noImplicitAny"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 设置为true时，如果不是函数中的所有路径都有返回值，则提示Error</span></span><br><span class="line">      <span class="string">"noImplicitReturns"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// module 用于指定模块的代码生成规则，可以使用 commonjs 、 amd 、 umd 、 system 、 es6 、 es2015 、 none 这些选项。</span></span><br><span class="line">      <span class="comment">// 选择commonJS，会生成符合commonjs规范的文件，使用amd，会生成满足amd规范的文件，使用system会生成使用ES6的</span></span><br><span class="line">      <span class="comment">// system.import的代码。使用es6或者是es2015会生产包含ES6特性的代码。</span></span><br><span class="line">      <span class="string">"module"</span>: <span class="string">"es2015"</span>,</span><br><span class="line">      <span class="string">"moduleResolution"</span>: <span class="string">"node"</span>,</span><br><span class="line">      <span class="comment">// 设置为true时，则允许从没有默认导出的模块中默认导入(也就是不做检查)</span></span><br><span class="line">      <span class="string">"allowSyntheticDefaultImports"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 设置为true，则支持ES7的装饰器特性</span></span><br><span class="line">      <span class="string">"experimentalDecorators"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// target 用于指定生成代码的兼容版本，可以从es3,es5,es2015,es6中选择一个，如果不设置，默认生产的代码兼容到es3</span></span><br><span class="line">      <span class="string">"target"</span>: <span class="string">"es5"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"include"</span>: [</span><br><span class="line">        <span class="string">"./src/**/*"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置参考： </p><ul><li><a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener">官方文档tsconfig解析</a> </li><li><a href="http://json.schemastore.org/tsconfig" target="_blank" rel="noopener">tsconfig的JSON文档</a></li></ul><h2 id="Webpack的基础配置一览"><a href="#Webpack的基础配置一览" class="headerlink" title="Webpack的基础配置一览"></a>Webpack的基础配置一览</h2><p>每个项目最重要的一部分个人感觉是webpack的配置，只有配置好webpack部分后续才能顺利进行开发</p><p>这里webpack使用了4.+的版本，所以算是体验了较为新的webpack，其中和旧版的有些区别，这里不做介绍</p><p>先贴出webpack的配置代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="string">'production'</span> : <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.ts'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">    publicPath: <span class="string">'/dist/'</span>,</span><br><span class="line">    filename: <span class="string">'build.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        loader: <span class="string">'vue-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          loaders: &#123;</span><br><span class="line">            <span class="string">'scss'</span>: <span class="string">'vue-style-loader!css-loader!sass-loader'</span>,</span><br><span class="line">            <span class="string">'sass'</span>: <span class="string">'vue-style-loader!css-loader!sass-loader?indentedSyntax'</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">        loader: <span class="string">'ts-loader'</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          transpileOnly: <span class="literal">true</span>,</span><br><span class="line">          appendTsSuffixTo: [<span class="regexp">/.vue$/</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">'.ts'</span>, <span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.josn'</span>],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'vue$'</span>: <span class="string">'vue/dist/vue.esm.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./public'</span>,</span><br><span class="line">    host: <span class="string">'localhost'</span>,</span><br><span class="line">    port: <span class="string">'8080'</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    inline: <span class="literal">true</span>,</span><br><span class="line">    historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">    noInfo: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  performance: &#123;</span><br><span class="line">    hints: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">'#eval-source-map'</span>,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> VueLoaderPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports.devtool = <span class="string">'#source-map'</span></span><br><span class="line">  <span class="built_in">module</span>.exports.plugins = (<span class="built_in">module</span>.exports.plugins || []).concat([</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env'</span>: &#123;</span><br><span class="line">        NODE_ENV: <span class="string">'"production"'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">      sourceMap: <span class="literal">true</span>,</span><br><span class="line">      compress: &#123;</span><br><span class="line">        warnings: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.LoaderOptionsPlugin(&#123;</span><br><span class="line">      minimize: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports.plugins = (<span class="built_in">module</span>.exports.plugins || []).concat([</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li><p>vue-loader v15需要在webpack插件中添加VueLoaderPlugin插件</p></li><li><p>webpack4.+需要指定mode，开发模式还是生产模式</p></li><li><p>注意ts-loader的配置</p></li></ul><p>这里只是简单进行webpack配置，没有太完整地根据完整的项目来进行配置，只是简单配置了生产环境下的代码混淆压缩，以及对应的开发服务器和热更新等，有需要其他功能扩展的自行配置。</p><h2 id="Vue环境搭建配置"><a href="#Vue环境搭建配置" class="headerlink" title="Vue环境搭建配置"></a>Vue环境搭建配置</h2><h3 id="vue-shims-d-ts的添加"><a href="#vue-shims-d-ts的添加" class="headerlink" title="vue-shims.d.ts的添加"></a>vue-shims.d.ts的添加</h3><p>这个是比较重要的一个配置，该文件需要放到vue的入口文件中，具体的d.ts代码如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> '*.vue' &#123;</span><br><span class="line">  <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目的是让ts能够识别到vue的静态类型</p><h3 id="vue的入口文件"><a href="#vue的入口文件" class="headerlink" title="vue的入口文件"></a>vue的入口文件</h3><p>index.ts:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="comment">// vuex部分</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>入口文件跟普通的js写法没有太多的区别，只是文件类型为ts。</p><h2 id="开始写vue的单文件页面和组件"><a href="#开始写vue的单文件页面和组件" class="headerlink" title="开始写vue的单文件页面和组件"></a>开始写vue的单文件页面和组件</h2><h3 id="单文件页面模板"><a href="#单文件页面模板" class="headerlink" title="单文件页面模板"></a>单文件页面模板</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script lang="ts"&gt;</span></span><br><span class="line"><span class="regexp">  ...</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><p>主要是在script项中把lang写为ts类型</p><h3 id="使用装饰器来实现组件和页面"><a href="#使用装饰器来实现组件和页面" class="headerlink" title="使用装饰器来实现组件和页面"></a>使用装饰器来实现组件和页面</h3><p>这里我们主要使用两个装饰器库vue-property-decorator 和 vuex-class, vue-property-decorator其是基于vue-class-得component的基础扩展修改的。</p><ol><li>大致了解一下vue-property-decorator的装饰器的用法</li></ol><p>一共有七个装饰器：</p><ul><li><code>@Emit</code></li><li><code>@Inject</code></li><li><code>@Model</code></li><li><code>@Prop</code></li><li><code>@Provide</code></li><li><code>@Watch</code></li><li><code>@Component</code> (<strong>exported from</strong> <code>vue-class-component</code>)</li></ul><p>这里使用vue-property-decorator的例子来做解析</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Emit, Inject, Model, Prop, Provide, Vue, Watch &#125; <span class="keyword">from</span> <span class="string">'vue-property-decorator'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = Symbol(<span class="string">'baz'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MyComponent <span class="keyword">extends</span> Vue &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Emit</span>()</span><br><span class="line">  addToCount(n: <span class="built_in">number</span>)&#123; <span class="keyword">this</span>.count += n &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Emit</span>(<span class="string">'reset'</span>)</span><br><span class="line">  resetCount()&#123; <span class="keyword">this</span>.count = <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span>() foo: <span class="built_in">string</span></span><br><span class="line">  <span class="meta">@Inject</span>(<span class="string">'bar'</span>) bar: <span class="built_in">string</span></span><br><span class="line">  <span class="meta">@Inject</span>(&#123;<span class="keyword">from</span>: <span class="string">'optional'</span>, <span class="keyword">default</span>: <span class="string">'default'</span>&#125;) optional: <span class="built_in">string</span></span><br><span class="line">  <span class="meta">@Inject</span>(s) baz: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Model</span>(<span class="string">'change'</span>) checked: <span class="built_in">boolean</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Prop</span>()</span><br><span class="line">  propA: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Prop</span>(&#123; <span class="keyword">default</span>: <span class="string">'default value'</span> &#125;)</span><br><span class="line">  propB: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Prop</span>([<span class="built_in">String</span>, <span class="built_in">Boolean</span>])</span><br><span class="line">  propC: <span class="built_in">string</span> | <span class="built_in">boolean</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Provide</span>() foo = <span class="string">'foo'</span></span><br><span class="line">  <span class="meta">@Provide</span>(<span class="string">'bar'</span>) baz = <span class="string">'bar'</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Watch</span>(<span class="string">'child'</span>)</span><br><span class="line">  onChildChanged(val: <span class="built_in">string</span>, oldVal: <span class="built_in">string</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Watch</span>(<span class="string">'person'</span>, &#123; immediate: <span class="literal">true</span>, deep: <span class="literal">true</span> &#125;)</span><br><span class="line">  onPersonChanged(val: Person, oldVal: Person) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于js的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="built_in">Symbol</span>(<span class="string">'baz'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MyComponent = Vue.extend(&#123;</span><br><span class="line">  name: <span class="string">'MyComponent'</span>,</span><br><span class="line">  inject: &#123;</span><br><span class="line">    foo: <span class="string">'foo'</span>,</span><br><span class="line">    bar: <span class="string">'bar'</span>,</span><br><span class="line">    <span class="string">'optional'</span>: &#123; <span class="attr">from</span>: <span class="string">'optional'</span>, <span class="attr">default</span>: <span class="string">'default'</span> &#125;,</span><br><span class="line">    [s]: s</span><br><span class="line">  &#125;,</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">'checked'</span>,</span><br><span class="line">    event: <span class="string">'change'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    checked: <span class="built_in">Boolean</span>,</span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    propB: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'default value'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    propC: [<span class="built_in">String</span>, <span class="built_in">Boolean</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      foo: <span class="string">'foo'</span>,</span><br><span class="line">      baz: <span class="string">'bar'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  provide () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      foo: <span class="keyword">this</span>.foo,</span><br><span class="line">      bar: <span class="keyword">this</span>.baz</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addToCount(n)&#123;</span><br><span class="line">      <span class="keyword">this</span>.count += n</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">"add-to-count"</span>, n)</span><br><span class="line">    &#125;,</span><br><span class="line">    resetCount()&#123;</span><br><span class="line">      <span class="keyword">this</span>.count = <span class="number">0</span></span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">"reset"</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    onChildChanged(val, oldVal) &#123; &#125;,</span><br><span class="line">    onPersonChanged(val, oldVal) &#123; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="string">'child'</span>: &#123;</span><br><span class="line">      handler: <span class="string">'onChildChanged'</span>,</span><br><span class="line">      immediate: <span class="literal">false</span>,</span><br><span class="line">      deep: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'person'</span>: &#123;</span><br><span class="line">      handler: <span class="string">'onPersonChanged'</span>,</span><br><span class="line">      immediate: <span class="literal">true</span>,</span><br><span class="line">      deep: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>相信通过以上的例子我们很容易就看出各个装饰器如何去使用，这里就不再做太多的解释。</p><ol start="2"><li>再看一下vuex-class的使用方法</li></ol><p>同样举例官方的使用列子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">'vue-class-component'</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  State,</span><br><span class="line">  Getter,</span><br><span class="line">  Action,</span><br><span class="line">  Mutation,</span><br><span class="line">  namespace</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'vuex-class'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> someModule = namespace(<span class="string">'path/to/module'</span>)</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  @State(<span class="string">'foo'</span>) stateFoo</span><br><span class="line">  @State(<span class="function"><span class="params">state</span> =&gt;</span> state.bar) stateBar</span><br><span class="line">  @Getter(<span class="string">'foo'</span>) getterFoo</span><br><span class="line">  @Action(<span class="string">'foo'</span>) actionFoo</span><br><span class="line">  @Mutation(<span class="string">'foo'</span>) mutationFoo</span><br><span class="line">  @someModule.Getter(<span class="string">'foo'</span>) moduleGetterFoo</span><br><span class="line"></span><br><span class="line">  @State foo</span><br><span class="line">  @Getter bar</span><br><span class="line">  @Action baz</span><br><span class="line">  @Mutation qux</span><br><span class="line"></span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="keyword">this</span>.stateFoo <span class="comment">// -&gt; store.state.foo</span></span><br><span class="line">    <span class="keyword">this</span>.stateBar <span class="comment">// -&gt; store.state.bar</span></span><br><span class="line">    <span class="keyword">this</span>.getterFoo <span class="comment">// -&gt; store.getters.foo</span></span><br><span class="line">    <span class="keyword">this</span>.actionFoo(&#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; store.dispatch('foo', &#123; value: true &#125;)</span></span><br><span class="line">    <span class="keyword">this</span>.mutationFoo(&#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; store.commit('foo', &#123; value: true &#125;)</span></span><br><span class="line">    <span class="keyword">this</span>.moduleGetterFoo <span class="comment">// -&gt; store.getters['path/to/module/foo']</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vuex的配置"><a href="#Vuex的配置" class="headerlink" title="Vuex的配置"></a>Vuex的配置</h2><h3 id="store的入口"><a href="#store的入口" class="headerlink" title="store的入口"></a>store的入口</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex, &#123; StoreOptions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> &#123; RootState &#125; <span class="keyword">from</span> <span class="string">'./modules/types'</span></span><br><span class="line"><span class="keyword">import</span> &#123; profile &#125; <span class="keyword">from</span> <span class="string">'./modules/profile'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store: StoreOptions&lt;RootState&gt; = &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    version: <span class="string">'v1.0.0'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">    profile</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store&lt;RootState&gt;(store);</span><br></pre></td></tr></table></figure><p>这里RootState只是用于留空，目的是为了注入全局的store，区别于modules的状态</p><h3 id="vuex的modules的配置"><a href="#vuex的modules的配置" class="headerlink" title="vuex的modules的配置"></a>vuex的modules的配置</h3><ol><li>写一个全局类型声明</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> RootState &#123;</span><br><span class="line">  version: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>version字段就是我们刚才在RootState中定义的字段</p><ol start="2"><li>定义模板profile</li></ol><p>profile模块的类型声明:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ProfileState &#123;</span><br><span class="line">  firstName: <span class="built_in">string</span></span><br><span class="line">  lastName: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>profile的模块实现:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; RootState &#125; <span class="keyword">from</span> <span class="string">'../types'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> &#123; ProfileState &#125; <span class="keyword">from</span> <span class="string">'./types'</span></span><br><span class="line"><span class="keyword">import</span> &#123; GetterTree, ActionTree, MutationTree  &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> axios, &#123; AxiosPromise &#125; <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state: ProfileState = &#123;</span><br><span class="line">  firstName: <span class="string">''</span>,</span><br><span class="line">  lastName: <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getters: GetterTree&lt;ProfileState, RootState&gt; = &#123;</span><br><span class="line">  firstName(state) : <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.firstName</span><br><span class="line">  &#125;,</span><br><span class="line">  lastName(state) : <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.lastName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions: ActionTree&lt;ProfileState, RootState&gt; = &#123;</span><br><span class="line">  fetchName(&#123; commit &#125;, id: <span class="built_in">number</span>): AxiosPromise&lt;ProfileState&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'action:'</span>, id)</span><br><span class="line">    <span class="keyword">return</span> axios.request(&#123;</span><br><span class="line">      url: <span class="string">'https://www.apiopen.top/satinCommentApi?id=27610708&amp;page=1'</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'setProfile'</span>, &#123;</span><br><span class="line">        firstName: <span class="string">'lin'</span>,</span><br><span class="line">        lastName: <span class="string">'guangyu'</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations: MutationTree&lt;ProfileState&gt; = &#123;</span><br><span class="line">  setProfile(state, payload: ProfileState) &#123;</span><br><span class="line">    state.firstName = payload.firstName</span><br><span class="line">    state.lastName = payload.lastName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> namespaced: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> profile: Module&lt;ProfileState, RootState&gt; = &#123;</span><br><span class="line">  namespaced,</span><br><span class="line">  state,</span><br><span class="line">  getters,</span><br><span class="line">  actions,</span><br><span class="line">  mutations</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我们就完成了Vuex的配置了，就可以结合装饰器对vuex进行调用，而且具有静态类型提示，十分方便。</p><p>完成了这一系列的配置我们的尝试已经完成，自己写了个简单的demo，有兴趣可以观看<a href="https://github.com/lgybetter/vue-ts-template" target="_blank" rel="noopener">github</a>怎么配置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/VuexStorageTS.png&quot; alt=&quot;banner&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;静态类型系统能帮助你有效防止许多潜在的运行时错误，而且随着你的应用日渐丰满会更加显著。这就是为什么 Vue 不仅仅为 Vue cor
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
      <category term="TypeScript" scheme="http://yoursite.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>React结合TypeScript和Mobx初体验</title>
    <link href="http://yoursite.com/2018/05/05/React%E7%BB%93%E5%90%88TypeScript%E5%92%8CMobx%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://yoursite.com/2018/05/05/React结合TypeScript和Mobx初体验/</id>
    <published>2018-05-05T13:16:42.000Z</published>
    <updated>2021-07-20T03:24:10.676Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/20180505210245.png" alt="banner"></p><h2 id="为什么要使用TypeScript"><a href="#为什么要使用TypeScript" class="headerlink" title="为什么要使用TypeScript"></a>为什么要使用TypeScript</h2><h3 id="侦测错误"><a href="#侦测错误" class="headerlink" title="侦测错误"></a>侦测错误</h3><p>通过静态类型检测可以尽早检测出程序中隐藏的的逻辑错误，对于JavaScript动态的弱类型语言，虽然灵活性高，但是对于初学者来说，如果不熟悉JavaScript内部的语言机制，很容易造成隐藏的事故。但是通过TypeScript的静态类型检测可以规避这些问题，因为其能够约束变量产生的类型。结合IDE编辑器可以推导变量对应的类型以及内部的结构，提高代码的健壮性和可维护性。</p><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>类型系统能够强化规范编程，TypeScript提供定义接口。在开发大型复杂的应用软件时十分重要，一个系统模块可以抽象的看做一个TypeScript定义的接口。让设计脱离实现，最终体现出一种 IDL（接口定义语言，Interface Define Language），让程序设计回归本质。</p><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>TypeScript可以自动根据类型标注生成文档，对于简单的功能实现都不需要编写注释。</p><h2 id="为什么要使用Mobx"><a href="#为什么要使用Mobx" class="headerlink" title="为什么要使用Mobx"></a>为什么要使用Mobx</h2><h3 id="MobX-和-Redux-的比较"><a href="#MobX-和-Redux-的比较" class="headerlink" title="MobX 和 Redux 的比较"></a>MobX 和 Redux 的比较</h3><p>先要明白 mobx 和 redux 的定位是不同的。redux 管理的是 (STORE -&gt; VIEW -&gt; ACTION) 的整个闭环，而 mobx 只关心 STORE -&gt; VIEW 的部分。</p><p>Redux优缺点：</p><ul><li><p>数据流流动很自然，因为任何 dispatch 都会触发广播，依据对象引用是否变化来控制更新粒度。</p></li><li><p>通过充分利用时间回溯的特征，可以增强业务的可预测性与错误定位能力。</p></li><li><p>时间回溯代价高，因为每次都要更新引用，除非增加代码复杂度，或使用 immutable。</p></li><li><p>时间回溯的另一个代价是 action 与 reducer 完全脱节，原因是可回溯必然不能保证引用关系。</p></li><li><p>引入中间件，解决异步带来的副作用，业务逻辑或多或少参杂着 magic。</p></li><li><p>灵活利用中间件，可以通过约定完成许多复杂的工作。</p></li><li><p>对 typescript 支持困难。</p></li></ul><p>Mobx优缺点：</p><ul><li><p>数据流流动不自然，只有用到的数据才会引发绑定，局部精确更新，但避免了粒度控制烦恼。</p></li><li><p>没有时间回溯能力，因为数据只有一份引用。自始至终一份引用，不需要 immutable，也没有复制对象的额外开销。</p></li><li><p>数据流动由函数调用一气呵成，便于调试。</p></li><li><p>业务开发不是脑力活，而是体力活，少一些 magic，多一些效率。</p></li><li><p>由于没有 magic，所以没有中间件机制，没法通过 magic 加快工作效率（这里 magic 是指 action 分发到 reducer 的过程）。</p></li><li><p>完美支持 typescript。</p></li></ul><p>SO: 前端数据流不太复杂的情况，使用 Mobx，因为更加清晰，也便于维护；如果前端数据流极度复杂，建议谨慎使用 Redux，通过中间件减缓巨大业务复杂度</p><h2 id="使用Create-React-App来建立TypeScript的环境"><a href="#使用Create-React-App来建立TypeScript的环境" class="headerlink" title="使用Create-React-App来建立TypeScript的环境"></a>使用Create-React-App来建立TypeScript的环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm i -g create-react-app</span><br><span class="line">create-react-app tinylog-ui --scripts-version=react-scripts-ts</span><br><span class="line"><span class="built_in">cd</span> tinylog-ui/</span><br><span class="line">npm start</span><br><span class="line">npm run eject</span><br></pre></td></tr></table></figure><p>TPS: 最后一个命令使用eject将所有内建的配置暴露出来</p><p>通过create-react-app可以很方便地对整个项目完成环境初始化，如果愿意折腾TypeScript和webpack的环境可以试试，这里忽略webpack和TypeScript的环境搭建过程，而是使用create-react-app来实现环境搭建。</p><h2 id="加入React-Router"><a href="#加入React-Router" class="headerlink" title="加入React-Router"></a>加入React-Router</h2><p>单页应用怎么可以没有前端路由呢，所以我们要加入React-Rotuer, 这里使用的React-Router的版本是v4.2.0</p><h3 id="路由配置使用姿势"><a href="#路由配置使用姿势" class="headerlink" title="路由配置使用姿势"></a>路由配置使用姿势</h3><p>对于React-Router，这里使用到的模块有Router, Route, Switch</p><blockquote><p>React Router 是建立在 history 之上的。 简而言之，一个 history 知道如何去监听浏览器地址栏的变化， 并解析这个 URL 转化为 location 对象， 然后 router 使用它匹配到路由，最后正确地渲染对应的组件。</p></blockquote><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &apos;react&apos;;</span><br><span class="line">import * as ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import &#123; Router, Route, Switch &#125; from &apos;react-router&apos;;</span><br><span class="line">import &#123; createBrowserHistory &#125; from &apos;history&apos;;</span><br><span class="line">import registerServiceWorker from &apos;./registerServiceWorker&apos;;</span><br><span class="line">import &#123; Root &#125; from &apos;./containers/Root&apos;;</span><br><span class="line">import &apos;./index.css&apos;;</span><br><span class="line">import Container from &apos;./containers/Container&apos;;</span><br><span class="line">import SignIn from &apos;./containers/Auth/signIn&apos;;</span><br><span class="line">import SignUp from &apos;./containers/Auth/signUp&apos;;</span><br><span class="line"></span><br><span class="line">const history = createBrowserHistory();</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Root&gt;</span><br><span class="line">    &lt;Router history=&#123;history&#125;&gt;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">        &lt;Route</span><br><span class="line">          path=&quot;/signIn&quot;</span><br><span class="line">          component=&#123;SignIn&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;Route</span><br><span class="line">          path=&quot;/signUp&quot;</span><br><span class="line">          component=&#123;SignUp&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;Route</span><br><span class="line">          path=&quot;/&quot;</span><br><span class="line">          component=&#123;Container&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/Switch&gt;</span><br><span class="line">    &lt;/Router&gt;</span><br><span class="line">  &lt;/Root&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;) as HTMLElement</span><br><span class="line">);</span><br><span class="line">registerServiceWorker();</span><br></pre></td></tr></table></figure><h3 id="页面的编写"><a href="#页面的编写" class="headerlink" title="页面的编写"></a>页面的编写</h3><p>这里描述一写Container这个组件的编写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &apos;react&apos;;</span><br><span class="line">import Header from &apos;../../layout/Header&apos;;</span><br><span class="line">import &#123; IAuth &#125; from &apos;../../interfaces&apos;;</span><br><span class="line">import &#123; Route, Switch &#125; from &apos;react-router&apos;;</span><br><span class="line">import App from &apos;../App&apos;;</span><br><span class="line">import Website from &apos;../Website&apos;;</span><br><span class="line"></span><br><span class="line">// 这部分是坑点，一开始不知道配置，后发现react-rotuer的4.0版本下需要配置prop的接口</span><br><span class="line">interface Container extends RouteComponentProps&lt;&#123;&#125;&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Container extends React.Component&lt;Container, &#123;&#125;&gt; &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Header &#123;...this.props&#125; /&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &lt;Route path=&quot;/website&quot; component=&#123;Website&#125;/&gt;</span><br><span class="line">          &lt;Route  path=&quot;/&quot; component=&#123;App&#125;/&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Container;</span><br></pre></td></tr></table></figure><p>这样，当我们访问url为’/‘的时候，默认会进入Container，其中Container里面是一层子页面，会匹配url，如果url为’/website’, 则进入Website页面，若为’/‘,则进入App页面。</p><p>具体关于React-Router的使用请阅读<a href="https://reacttraining.com/react-router/" target="_blank" rel="noopener">React-Router文档</a></p><h2 id="加入Mobx"><a href="#加入Mobx" class="headerlink" title="加入Mobx"></a>加入Mobx</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mobx react-mobx mobx-react-router -S</span><br></pre></td></tr></table></figure><h3 id="重新修改index-tsx的入口配置"><a href="#重新修改index-tsx的入口配置" class="headerlink" title="重新修改index.tsx的入口配置"></a>重新修改index.tsx的入口配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &apos;react&apos;;</span><br><span class="line">import * as ReactDOM from &apos;react-dom&apos;;</span><br><span class="line">import &#123; Router, Route, Switch &#125; from &apos;react-router&apos;;</span><br><span class="line">import &#123; createBrowserHistory &#125; from &apos;history&apos;;</span><br><span class="line">import &#123; useStrict &#125; from &apos;mobx&apos;;</span><br><span class="line">import &#123; Provider &#125; from &apos;mobx-react&apos;;</span><br><span class="line">import &#123; RouterStore, syncHistoryWithStore &#125; from &apos;mobx-react-router&apos;;</span><br><span class="line">// 定义需要使用到的store来进行数据状态的管理</span><br><span class="line">import &#123; </span><br><span class="line">  TokenStore, </span><br><span class="line">  AuthStore, </span><br><span class="line">  HostStore, </span><br><span class="line">  OverViewStore,</span><br><span class="line">  AssetsStore,</span><br><span class="line">  CommonDataStore,</span><br><span class="line">  PageStore,</span><br><span class="line">  RealTimeStore  </span><br><span class="line">&#125; from &apos;./stores&apos;;</span><br><span class="line">import registerServiceWorker from &apos;./registerServiceWorker&apos;;</span><br><span class="line">import &#123; Root &#125; from &apos;./containers/Root&apos;;</span><br><span class="line">import &apos;./index.css&apos;;</span><br><span class="line">import Container from &apos;./containers/Container&apos;;</span><br><span class="line">import SignIn from &apos;./containers/Auth/signIn&apos;;</span><br><span class="line">import SignUp from &apos;./containers/Auth/signUp&apos;;</span><br><span class="line">// 引入Echarts</span><br><span class="line">import &apos;./macarons&apos;;</span><br><span class="line">import &apos;echarts/map/js/world&apos;;</span><br><span class="line"></span><br><span class="line">// 开启mobx的严格模式，规范数据修改操作只能在action中进行</span><br><span class="line">useStrict(true);</span><br><span class="line"></span><br><span class="line">const browserHistory = createBrowserHistory();</span><br><span class="line">const routerStore =  new RouterStore();</span><br><span class="line">// 同步路由与mobx的数据状态</span><br><span class="line">const history = syncHistoryWithStore(browserHistory, routerStore);</span><br><span class="line">const rootStore = &#123;</span><br><span class="line">  token: new TokenStore(),</span><br><span class="line">  auth: new AuthStore(),</span><br><span class="line">  host: new HostStore(),</span><br><span class="line">  overview: new OverViewStore(),</span><br><span class="line">  assets: new AssetsStore(),</span><br><span class="line">  commmon: new CommonDataStore(),</span><br><span class="line">  page: new PageStore(),</span><br><span class="line">  realtime: new RealTimeStore(),</span><br><span class="line">  router: routerStore</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider &#123;...rootStore&#125;&gt;</span><br><span class="line">    &lt;Root&gt;</span><br><span class="line">      &lt;Router history=&#123;history&#125;&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &lt;Route</span><br><span class="line">            path=&quot;/signIn&quot;</span><br><span class="line">            component=&#123;SignIn&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">          &lt;Route</span><br><span class="line">            path=&quot;/signUp&quot;</span><br><span class="line">            component=&#123;SignUp&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">          &lt;Route</span><br><span class="line">            path=&quot;/&quot;</span><br><span class="line">            component=&#123;Container&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">      &lt;/Router&gt;</span><br><span class="line">    &lt;/Root&gt;</span><br><span class="line">  &lt;/Provider&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;) as HTMLElement</span><br><span class="line">);</span><br><span class="line">registerServiceWorker();</span><br></pre></td></tr></table></figure><h3 id="Container容器的修改"><a href="#Container容器的修改" class="headerlink" title="Container容器的修改"></a>Container容器的修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &apos;react&apos;;</span><br><span class="line">import Header from &apos;../../layout/Header&apos;;</span><br><span class="line">import &#123; IAuth &#125; from &apos;../../interfaces&apos;;</span><br><span class="line">import &#123; Route, Switch &#125; from &apos;react-router&apos;;</span><br><span class="line">// 使用inject和observer来进行数据监听和数据依赖声明</span><br><span class="line">import &#123; inject, observer &#125; from &apos;mobx-react&apos;;</span><br><span class="line">import App from &apos;../App&apos;;</span><br><span class="line">import Website from &apos;../Website&apos;;</span><br><span class="line"></span><br><span class="line">interface Container extends IAuth &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@inject(&apos;router&apos;, &apos;auth&apos;)</span><br><span class="line">@observer</span><br><span class="line">class Container extends React.Component&lt;Container, &#123;&#125;&gt; &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Header &#123;...this.props&#125; /&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &lt;Route path=&quot;/website&quot; component=&#123;Website&#125;/&gt;</span><br><span class="line">          &lt;Route  path=&quot;/&quot; component=&#123;App&#125;/&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Container;</span><br></pre></td></tr></table></figure><blockquote><p>@observable 可以在实例字段和属性 getter 上使用。 对于对象的哪部分需要成为可观察的，@observable 提供了细粒度的控制。</p></blockquote><blockquote><p>@inject 相当于Provider 的高阶组件。可以用来从 React 的context中挑选 store 作为 prop 传递给目标组件</p></blockquote><h3 id="组件的接口定义"><a href="#组件的接口定义" class="headerlink" title="组件的接口定义"></a>组件的接口定义</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; RouteComponentProps &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  RouterStore,</span><br><span class="line">  AuthStore</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../stores'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IBase <span class="keyword">extends</span> RouteComponentProps&lt;&#123;&#125;&gt; &#123;</span><br><span class="line">  router: RouterStore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IAuth <span class="keyword">extends</span> IBase &#123;</span><br><span class="line">  auth: AuthStore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Store的配置"><a href="#Store的配置" class="headerlink" title="Store的配置"></a>Store的配置</h3><p>先看一下RouterStore:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; History &#125; <span class="keyword">from</span> <span class="string">'history'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; RouterStore <span class="keyword">as</span> BaseRouterStore, syncHistoryWithStore &#125; <span class="keyword">from</span> <span class="string">'mobx-react-router'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由状态同步</span></span><br><span class="line"><span class="keyword">class</span> RouterStore <span class="keyword">extends</span> BaseRouterStore &#123;</span><br><span class="line">  <span class="keyword">public</span> history;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">history?: History</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">if</span> (history) &#123;</span><br><span class="line">      <span class="keyword">this</span>.history = syncHistoryWithStore(history, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> RouterStore;</span><br></pre></td></tr></table></figure><p>然后是AuthStore:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ISignIn, ISignUp &#125; <span class="keyword">from</span> <span class="string">'./../interfaces/index'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; observable, action &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">'../api/auth'</span>; </span><br><span class="line"><span class="keyword">import</span> &#123; IUser &#125; <span class="keyword">from</span> <span class="string">'../models'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录注册状态</span></span><br><span class="line"><span class="keyword">class</span> AuthStore &#123;</span><br><span class="line">  <span class="meta">@observable</span> token;</span><br><span class="line">  <span class="meta">@observable</span> id;</span><br><span class="line">  <span class="meta">@observable</span> email;</span><br><span class="line">  <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">this</span>.token = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">this</span>.email = <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  setLocalStorage (&#123; id, token, email &#125;: IUser) &#123;</span><br><span class="line">    localStorage.setItem(<span class="string">'id'</span>, id);</span><br><span class="line">    localStorage.setItem(<span class="string">'token'</span>, token);</span><br><span class="line">    localStorage.setItem(<span class="string">'email'</span>, email);</span><br><span class="line">  &#125;</span><br><span class="line">  clearStorage () &#123;</span><br><span class="line">    localStorage.clear();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@action</span> <span class="keyword">async</span> signIn (data: ISignIn) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; data: res &#125; = <span class="keyword">await</span> api.signIn(data);</span><br><span class="line">      <span class="keyword">this</span>.id = res.data.id;</span><br><span class="line">      <span class="keyword">this</span>.token = res.data.token;</span><br><span class="line">      <span class="keyword">this</span>.email = res.data.email;</span><br><span class="line">      <span class="keyword">this</span>.setLocalStorage(&#123;</span><br><span class="line">        id: <span class="keyword">this</span>.id,</span><br><span class="line">        token: <span class="keyword">this</span>.token,</span><br><span class="line">        email: <span class="keyword">this</span>.email</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@action</span> <span class="keyword">async</span> signUp (data: ISignUp) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; data: res &#125; = <span class="keyword">await</span> api.signUp(data);</span><br><span class="line">      <span class="keyword">this</span>.id = res.data.id;</span><br><span class="line">      <span class="keyword">this</span>.token = res.data.token;</span><br><span class="line">      <span class="keyword">this</span>.email = res.data.email;</span><br><span class="line">      <span class="keyword">this</span>.setLocalStorage(&#123;</span><br><span class="line">        id: <span class="keyword">this</span>.id,</span><br><span class="line">        token: <span class="keyword">this</span>.token,</span><br><span class="line">        email: <span class="keyword">this</span>.email</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@action</span> signOut () &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">this</span>.token = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">this</span>.email = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">this</span>.clearStorage()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> AuthStore;</span><br></pre></td></tr></table></figure><p>Auth是用于网站的登录注册事件以及对应的Token的数据状态保存，登录注册事件的接口请求等操作。</p><p>具体的有关Mobx的用法请阅读<a href="https://cn.mobx.js.org/" target="_blank" rel="noopener">Mobx文档</a></p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app</span><br><span class="line">├── api             后端提供的接口数据请求</span><br><span class="line">├── components      编写的可复用组件</span><br><span class="line">├── config          侧边栏以及导航栏配置</span><br><span class="line">├── constants       常量编写</span><br><span class="line">├── interfaces      接口编写</span><br><span class="line">├── layout          布局外框</span><br><span class="line">├── stores          mobx的数据状态管理</span><br><span class="line">├── index.css       全局样式</span><br><span class="line">├── index.tsx       页面入口</span><br><span class="line">├── reset.css       浏览器重置样式</span><br></pre></td></tr></table></figure><p>本项目使用了Ant-Design来作为依赖的组件库，具体怎么使用以及配置请参考<a href="https://ant.design/docs/react/use-in-typescript-cn" target="_blank" rel="noopener">Ant-Design</a></p><p>到这里其实以及完成对React下TypeScript结合React-Router和Mobx的配置。具体的业务模块如何编写有兴趣可以参阅项目<a href="https://github.com/tinylog/tinylog-ui" target="_blank" rel="noopener">tinylog-ui</a></p><p>个人表达能力有限，无法描述得太清晰，请见谅！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/20180505210245.png&quot; alt=&quot;banner&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么要使用TypeScript&quot;&gt;&lt;a href=&quot;#为什么要使用TypeScript&quot; class=&quot;headerlink&quot; title=&quot;为
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
      <category term="TypeScript" scheme="http://yoursite.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>高举 Vue-SSR</title>
    <link href="http://yoursite.com/2018/03/31/%E9%AB%98%E4%B8%BEvue-ssr/"/>
    <id>http://yoursite.com/2018/03/31/高举vue-ssr/</id>
    <published>2018-03-31T12:25:30.000Z</published>
    <updated>2021-07-20T03:24:10.676Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将静态标记”混合”为客户端上完全交互的应用程序。</p></blockquote><hr><h2 id="SSR的目的"><a href="#SSR的目的" class="headerlink" title="SSR的目的"></a>SSR的目的</h2><p>To solve</p><ul><li><p>首屏渲染问题</p></li><li><p>SEO问题</p></li></ul><hr><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vue-ssr</span><br><span class="line">├── build                 (webapck编译配置)</span><br><span class="line">├── components            (vue 页面) </span><br><span class="line">├── dist                  (编译后的静态资源目录)</span><br><span class="line">├── api.js                (请求接口，模拟异步请求)</span><br><span class="line">├── app.js                (创建Vue实例入口)</span><br><span class="line">├── App.vue               (Vue页面入口)</span><br><span class="line">├── entry-client.js       (前端执行入口)</span><br><span class="line">├── entry-server.js       (后端执行入口)</span><br><span class="line">├── index.template.html   (前端渲染模板)</span><br><span class="line">├── router.js             (Vue路由配置)</span><br><span class="line">├── server.js             (Koa服务)</span><br><span class="line">├── store.js              (Vuex数据状态中心配置)</span><br></pre></td></tr></table></figure><hr><h2 id="原理概览"><a href="#原理概览" class="headerlink" title="原理概览"></a>原理概览</h2><p><img src="/images/vue-ssr.png" alt="vue-ssr"></p><p>这张图相信很多大佬们都看过N遍了，每个人理解不同，我发表一下自己个人的理解，如果有什么理解错误请原谅我。</p><p>先看Source部分，Source部分先由app.js引入Vue全家桶，至于Vue全家桶如何配置后面会说明。app.js其实就是创建一个注册好各种依赖的Vue对象实例，在SPA单页环境下，我们只需要拿到这个Vue实例，然后指定挂载到模板特定的dom结点，然后丢给webpack处理就完事了。但是SSR在此分为两部分，一部分是前端单页，一部分是后端直出。于是，Client entry的作用是挂载Vue对象实例，并由webpack进行编译打包，最后在浏览器渲染。Server entry的作用是拿到Vue对象实例，并处理收集页面中的asynData，获取对应的数据上下文，然后再由webpack解析处理。最后Node Server端中使用weback编译好的两个bundle文件( 服务器需要「服务器 bundle」然后用于服务器端渲染(SSR)，而「客户端 bundle」会发送给浏览器，用于混合静态标记。)，当用户请求页面时候，这时候服务端会先使用SSR来生成对应的页面文档结构，而在用户切换路由则是使用了SPA的模式。</p><hr><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><h3 id="项目依赖说明"><a href="#项目依赖说明" class="headerlink" title="项目依赖说明"></a>项目依赖说明</h3><p>Koa2 + Vue2 +  Vue-router + Vuex</p><h3 id="一切都从路由开始"><a href="#一切都从路由开始" class="headerlink" title="一切都从路由开始"></a>一切都从路由开始</h3><p>先来配置vue-router, 生成router.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> Bar <span class="keyword">from</span> <span class="string">'./components/Bar.vue'</span></span><br><span class="line"><span class="keyword">import</span> Baz <span class="keyword">from</span> <span class="string">'./components/Baz.vue'</span></span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'./components/Foo.vue'</span></span><br><span class="line"><span class="keyword">import</span> Item <span class="keyword">from</span> <span class="string">'./components/Item.vue'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createRouter = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    mode: <span class="string">'history'</span>,</span><br><span class="line">    routes: [</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">'/item/:id'</span>, <span class="attr">component</span>: Item &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">'/bar'</span>, <span class="attr">component</span>: Bar &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">'/baz'</span>, <span class="attr">component</span>: Baz &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">'/foo'</span>, <span class="attr">component</span>: Foo &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为每个请求创建一个新的Vue实例，路由也是如此，通过一个工厂函数来保证每次都是新创建一个Vue路由的新实例。</p><h3 id="Vuex-配置"><a href="#Vuex-配置" class="headerlink" title="Vuex 配置"></a>Vuex 配置</h3><p>配置Vuex, 生成store.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> &#123; fetchItem &#125; <span class="keyword">from</span> <span class="string">'./api'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createStore = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">      items: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">      fetchItem (&#123; commit &#125;, id) &#123;</span><br><span class="line">        <span class="keyword">return</span> fetchItem(id).then(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">          commit(<span class="string">'setItem'</span>, &#123; id, item &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">      setItem (state, &#123; id, item &#125;) &#123;</span><br><span class="line">        Vue.set(state.items, id, item)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样也是通过一个工厂函数，来创建一个新的Vuex实例并暴露该方法</p><h3 id="生成一个Vue的根实例"><a href="#生成一个Vue的根实例" class="headerlink" title="生成一个Vue的根实例"></a>生成一个Vue的根实例</h3><p>创建Vue实例，生成app.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter &#125; <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"><span class="keyword">import</span> &#123; sync &#125; <span class="keyword">from</span> <span class="string">'vuex-router-sync'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createApp = <span class="function"><span class="params">ssrContext</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> router = createRouter()</span><br><span class="line">  <span class="keyword">const</span> store = createStore()</span><br><span class="line"></span><br><span class="line">  sync(store, router)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    router,</span><br><span class="line">    store,</span><br><span class="line">    ssrContext,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123; </span><br><span class="line">    app, </span><br><span class="line">    store, </span><br><span class="line">    router </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用我们编写的createRouter, createStore来每次都创建新的Vue-router和Vuex实例，保证和Vue的实例一样都是重新创建过的，接着挂载注册router和store到Vue的实例中，提供createApp传入服务端渲染对应的数据上下文。</p><p>到此我们已经基本完成source部分的工作了。接着就要考虑如何去编译打包这些文件，让浏览器和Node服务端去运行解析。</p><h3 id="先从前端入口文件开始"><a href="#先从前端入口文件开始" class="headerlink" title="先从前端入口文件开始"></a>先从前端入口文件开始</h3><p>前端打包入口文件: entry-client.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'./app'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; </span><br><span class="line">  app, </span><br><span class="line">  store,</span><br><span class="line">  router </span><br><span class="line">&#125; = createApp()</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.__INITIAL_STATE__) &#123;</span><br><span class="line">  store.replaceState(<span class="built_in">window</span>.__INITIAL_STATE__)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.onReady(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  router.beforeResolve(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> matched = router.getMatchedComponents(to)</span><br><span class="line">    <span class="keyword">const</span> prevMatched = router.getMatchedComponents(<span class="keyword">from</span>)</span><br><span class="line">    <span class="keyword">let</span> diffed = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> activated = matched.filter(<span class="function">(<span class="params">c, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> diffed || (diffed = (prevMatched[i] !== c))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (!activated.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> next()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Promise</span>.all(activated.map(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (c.asyncData) &#123;</span><br><span class="line">        <span class="keyword">return</span> c.asyncData(&#123; store, <span class="attr">route</span>: to &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125;).catch(next)</span><br><span class="line">  &#125;)</span><br><span class="line">  app.$mount(<span class="string">'#app'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>客户端的entry只需创建应用程序，并且将其挂载到 DOM 中， 需要注意的是，任然需要在挂载 app 之前调用 router.onReady，因为路由器必须要提前解析路由配置中的异步组件，(如果你有使用异步组件的话，本项目没有使用到异步组件，但后续考虑加入) 才能正确地调用组件中可能存在的路由钩子。通过添加路由钩子函数，用于处理 asyncData，在初始路由 resolve 后执行，以便我们不会二次预取(double-fetch)已有的数据。使用 <code>router.beforeResolve()</code>，以便确保所有异步组件都 resolve，并对比之前没有渲染的组件找出两个匹配列表的差异组件，如果没有差异表示无需处理直接next输出。</p><h3 id="再看服务端渲染解析入口文件"><a href="#再看服务端渲染解析入口文件" class="headerlink" title="再看服务端渲染解析入口文件"></a>再看服务端渲染解析入口文件</h3><p>服务端渲染的执行入口文件: entry-server.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'./app'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> context =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; </span><br><span class="line">      app, </span><br><span class="line">      store,</span><br><span class="line">      router </span><br><span class="line">    &#125; = createApp(context)</span><br><span class="line"></span><br><span class="line">    router.push(context.url)</span><br><span class="line"></span><br><span class="line">    router.onReady(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> matchedComponents = router.getMatchedComponents()</span><br><span class="line">      <span class="keyword">if</span> (!matchedComponents.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(&#123; <span class="attr">code</span>: <span class="number">404</span> &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">Promise</span>.all(matchedComponents.map(<span class="function"><span class="params">Component</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Component.asyncData) &#123;</span><br><span class="line">          <span class="keyword">return</span> Component.asyncData(&#123;</span><br><span class="line">            store,</span><br><span class="line">            route: router.currentRoute</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        context.state = store.state</span><br><span class="line">        resolve(app)</span><br><span class="line">      &#125;).catch(reject)</span><br><span class="line">    &#125;, reject)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器 entry 使用 default export 导出函数，并在每次渲染中重复调用此函数。此时，创建和返回应用程序实例之外，还在此执行服务器端路由匹配(server-side route matching)和数据预取逻辑(data pre-fetching logic)。在所有预取钩子(preFetch hook) resolve 后，我们的 store 现在已经填充入渲染应用程序所需的状态。当我们将状态附加到上下文，并且 <code>template</code> 选项用于 renderer 时，状态将自动序列化为 <code>window.__INITIAL_STATE__</code>，并注入 HTML。</p><h3 id="激动人心的来写webpack"><a href="#激动人心的来写webpack" class="headerlink" title="激动人心的来写webpack"></a>激动人心的来写webpack</h3><p>直接上手weback4.x版本</p><p>webpack配置分为3个配置，公用配置，客户端配置，服务端配置。</p><p>三个配置文件以此如下：</p><p>base config:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devtool: <span class="string">'#cheap-module-source-map'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line">    publicPath: <span class="string">'/'</span>,</span><br><span class="line">    filename: <span class="string">'[name]-[chunkhash].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'public'</span>: path.resolve(__dirname, <span class="string">'../public'</span>),</span><br><span class="line">      <span class="string">'components'</span>: path.resolve(__dirname, <span class="string">'../components'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    extensions: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'vue-loader'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">'babel-loader'</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: <span class="string">'css-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  performance: &#123;</span><br><span class="line">    maxEntrypointSize: <span class="number">300000</span>,</span><br><span class="line">    hints: <span class="string">'warning'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'common.[chunkhash].css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改配置只是简单的配置vue, css, babel等loader的使用，接着ExtractTextPlugin提取css资源文件，指定输出的目录，而入口文件则分别在client和server的config中配置。</p><p>client config</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base.config.js'</span>)</span><br><span class="line"><span class="keyword">const</span> VueSSRClientPlugin = <span class="built_in">require</span>(<span class="string">'vue-server-renderer/client-plugin'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(baseConfig, &#123;</span><br><span class="line">  entry: path.resolve(__dirname, <span class="string">'../entry-client.js'</span>),</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> VueSSRClientPlugin()</span><br><span class="line">  ],</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">          chunks: <span class="string">'initial'</span>,</span><br><span class="line">          minChunks: <span class="number">2</span>, <span class="attr">maxInitialRequests</span>: <span class="number">5</span>,</span><br><span class="line">          minSize: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        vendor: &#123;</span><br><span class="line">          test: <span class="regexp">/node_modules/</span>,</span><br><span class="line">          chunks: <span class="string">'initial'</span>,</span><br><span class="line">          name: <span class="string">'vendor'</span>,</span><br><span class="line">          priority: <span class="number">10</span>,</span><br><span class="line">          enforce: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    runtimeChunk: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>客户端的入口文件，使用VueSSRClientPlugin生成对应的vue-ssr-client-manifest.json的映射文件，然后添加vendor的chunk分离。</p><p>server config</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> nodeExternals = <span class="built_in">require</span>(<span class="string">'webpack-node-externals'</span>)</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">'./webpack.base.config.js'</span>)</span><br><span class="line"><span class="keyword">const</span> VueSSRServerPlugin = <span class="built_in">require</span>(<span class="string">'vue-server-renderer/server-plugin'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(baseConfig, &#123;</span><br><span class="line">  <span class="comment">// 将 entry 指向应用程序的 server entry 文件</span></span><br><span class="line">  entry: path.resolve(__dirname, <span class="string">'../entry-server.js'</span>),</span><br><span class="line">  <span class="comment">// 允许 webpack Node 适用方式(Node-appropriate fashion)处理动态导入(dynamic import)，</span></span><br><span class="line">  target: <span class="string">'node'</span>,</span><br><span class="line">  <span class="comment">// 提供 source map 支持</span></span><br><span class="line">  devtool: <span class="string">'source-map'</span>,</span><br><span class="line">  <span class="comment">// 使用 Node 风格导出模块(Node-style exports)</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'server-bundle.js'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'commonjs2'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  externals: nodeExternals(&#123;</span><br><span class="line">    <span class="comment">// 不要外置化 webpack 需要处理的依赖模块。</span></span><br><span class="line">    <span class="comment">// 你可以在这里添加更多的文件类型。例如，未处理 *.vue 原始文件，</span></span><br><span class="line">    <span class="comment">// 你还应该将修改 `global`（例如 polyfill）的依赖模块列入白名单</span></span><br><span class="line">    whitelist: <span class="regexp">/\.css$/</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="comment">// 这是将服务器的整个输出</span></span><br><span class="line">  <span class="comment">// 构建为单个 JSON 文件的插件。</span></span><br><span class="line">  <span class="comment">// 默认文件名为 `vue-ssr-server-bundle.json`</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> VueSSRServerPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>到此打包的流程已经结束了，server端配置参考了官网的注释。</p><h3 id="使用Koa2"><a href="#使用Koa2" class="headerlink" title="使用Koa2"></a>使用Koa2</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createBundleRenderer &#125; = <span class="built_in">require</span>(<span class="string">'vue-server-renderer'</span>)</span><br><span class="line"><span class="keyword">const</span> serverBundle = <span class="built_in">require</span>(<span class="string">'./dist/vue-ssr-server-bundle.json'</span>)</span><br><span class="line"><span class="keyword">const</span> clientManifest = <span class="built_in">require</span>(<span class="string">'./dist/vue-ssr-client-manifest.json'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>)</span><br><span class="line"><span class="keyword">const</span> KoaRuoter = <span class="built_in">require</span>(<span class="string">'koa-router'</span>)</span><br><span class="line"><span class="keyword">const</span> serve = <span class="built_in">require</span>(<span class="string">'koa-static'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> KoaRuoter()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> template = fs.readFileSync(path.resolve(<span class="string">'./index.template.html'</span>), <span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> renderer = createBundleRenderer(serverBundle, &#123;</span><br><span class="line">  <span class="comment">// 推荐</span></span><br><span class="line">  runInNewContext: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// （可选）页面模板</span></span><br><span class="line">  template, </span><br><span class="line">  <span class="comment">// （可选）客户端构建 manifest</span></span><br><span class="line">  clientManifest </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(serve(path.resolve(__dirname, <span class="string">'./dist'</span>)))</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'*'</span>, (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.set(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handleError = <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err &amp;&amp; err.code === <span class="number">404</span>) &#123;</span><br><span class="line">          ctx.status = <span class="number">404</span></span><br><span class="line">          ctx.body = <span class="string">'404 | Page Not Found'</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ctx.status = <span class="number">500</span></span><br><span class="line">          ctx.body = <span class="string">'500 | Internal Server Error'</span></span><br><span class="line">          <span class="built_in">console</span>.error(<span class="string">`error during render : <span class="subst">$&#123;ctx.url&#125;</span>`</span>)</span><br><span class="line">          <span class="built_in">console</span>.error(err.stack)</span><br><span class="line">      &#125;</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(ctx.url)</span><br><span class="line">    <span class="keyword">const</span> context = &#123; <span class="attr">url</span>: ctx.url, <span class="attr">title</span>: <span class="string">'Vue SSR'</span> &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 这里无需传入一个应用程序，因为在执行 bundle 时已经自动创建过。</span></span><br><span class="line">    <span class="comment">// 现在我们的服务器与应用程序已经解耦！</span></span><br><span class="line">    renderer.renderToString(context, (err, html) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 处理异常……</span></span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        handleError(err)</span><br><span class="line">      &#125;</span><br><span class="line">      ctx.body = html</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(router.routes()).use(router.allowedMethods())</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span></span><br><span class="line">app.listen(port, <span class="string">'127.0.0.1'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`server running at localhost:<span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最后效果当然是这样的了:</p><p><img src="/images/vue-ssr-res.png" alt="预览"></p><p>参考文档:</p><p><a href="https://ssr.vuejs.org/zh/," title="vue-ssr官方文档" target="_blank" rel="noopener">vue-ssr官方文档</a></p><p>代码仓库:</p><p><a href="https://github.com/lgybetter/vue-ssr-template," title="github 链接" target="_blank" rel="noopener">github链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将静态标记”混合”为客户端上完全交互的应用程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;SSR的目的&quot;&gt;&lt;a href=&quot;#SSR的目的&quot; clas
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>This浅析</title>
    <link href="http://yoursite.com/2017/11/14/This%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2017/11/14/This浅析/</id>
    <published>2017-11-13T16:02:26.000Z</published>
    <updated>2021-07-20T03:24:10.676Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/you-don-kown.jpg" alt="你不知道的js"></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>this的绑定和函数的声明位置没有任何关系，只取决于函数的调用方式。当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈），函数的调用方式，传入的参数等信息。this就是这个记录的一个属性，会在函数执行的过程中用到。</li></ul><h2 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h2><ul><li>调用位置就是函数在代码中被调用的位置（而不是声明位置）</li></ul><h2 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h2><ul><li>默认绑定</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">foo() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>当函数调用直接使用不带任何修饰的函数引用进行调用时，在非严格模式下，这时this会绑定到全局对象window/global，而在严格模式下，就会绑定到undefined</p><ul><li>隐式绑定</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>当函数引用拥有上下文对象时，隐式绑定规则会把函数调用中的this绑定到这个上下文对象。因为调用foo()时this被绑定到obj，因此this.a和obj.a是一样的。</p><ul><li>隐式丢失</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo <span class="comment">// 函数别名</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'lgybetter'</span></span><br><span class="line">bar() <span class="comment">// 'lgybetter'</span></span><br></pre></td></tr></table></figure><p>虽然bar是obj.foo的一个引用，但是它引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，使用了默认绑定(非严格模式)</p><ul><li>参数传递引起的隐式绑定</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'lgybetter'</span></span><br><span class="line">setTimeout(obj.foo, <span class="number">100</span>) <span class="comment">// 'lgybetter'</span></span><br></pre></td></tr></table></figure><p>JavaScript环境内置的setTimeout()函数实现和以下伪代码类似：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setTimeout</span> (<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  fn() <span class="comment">// &lt;--- 调用位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>显示绑定：</p><ul><li>call 和 apply：</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">foo.call(obj) <span class="comment">// 2</span></span><br><span class="line">foo.apply(obj) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>简单使用call和apply显示绑定无法解决丢失绑定问题</p><ul><li><p>硬绑定</p><ul><li>手动创建函数强制绑定</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo.call(obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar() <span class="comment">// 2</span></span><br><span class="line">setTimeout(bar, <span class="number">100</span>) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 硬绑定的bar不可能再修改它的this</span></span><br><span class="line">bar.call(<span class="built_in">window</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>通过创建bar()，并在它的内部手动调用foo.call(obj)，因此强制把foo的this绑定到了obj</p><ul><li>创建一个可以重复使用的函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">something</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, something)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span> (<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = bind(foo, obj)</span><br><span class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>) <span class="comment">// 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>由于硬绑定式一种非常常用的模式，于是ES5提供了内置方法Function.prototype.bind，bind会返回一个硬编码的新函数，它会把你指定的参数设置为this的上下文并调用原始函数。</p><ul><li>API调用的”上下文”：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(el, <span class="keyword">this</span>.id)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  id: <span class="string">'lgybetter'</span></span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].forEach(foo, obj)</span><br><span class="line"><span class="comment">// 1 lgybetter 2 lgybetter 3 lgybetter</span></span><br></pre></td></tr></table></figure><ul><li>new绑定:</li></ul><p>JavaScript中构造函数只是一些使用new操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。它们就是被new操作符调用的普通函数而已。<br>实际上，不存在所谓的构造函数，只有对函数的“构造调用”。</p><p>new调用函数操作：</p><ol><li>创建一个全新的对象</li><li>新对象会被执行[[Prototype]]连接</li><li>新对象会绑定到函数调用的this</li><li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(bar.a) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>使用new来调用Foo(…)， 会构造一个新对象并把它绑定到Foo(…)调用中的this上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/you-don-kown.jpg&quot; alt=&quot;你不知道的js&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;this的绑
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
</feed>
